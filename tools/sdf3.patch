diff -ruN sdf3_140724/sdf3/csdf/analysis/buffersizing/buffer.cc sdf3_custom/sdf3/csdf/analysis/buffersizing/buffer.cc
--- sdf3_140724/sdf3/csdf/analysis/buffersizing/buffer.cc	2014-07-24 12:16:04.000000000 +0800
+++ sdf3_custom/sdf3/csdf/analysis/buffersizing/buffer.cc	2022-07-12 16:37:20.841643588 +0800
@@ -37,8 +37,32 @@
 
 #include "buffer.h"
 #include "../throughput/throughput.h"
+#include <stack>
+// libraries for data logging
+#include <chrono>
+#include <string>
+// define variables to toggle verbose/extremely verbose/logging
+// #define VERBOSE_OUT // print out explored storage distributions and results
+// #define DEPS_OUT // extremely verbose output --- useful for understanding implementation of symbolic execution and storage deps
+#define LOG_OUT // log data of DSE in CSVs
+
 namespace CSDF
 {
+  #ifdef VERBOSE_OUT
+  long int computation_counter = 0;
+  #endif
+  bool useSCCStorageDeps = !strcmp(std::getenv("USE_SCC"), "true"); // TODO fix this workaround to not rely on keyword
+  bool useCoarse = !strcmp(std::getenv("COARSE"), "true"); // TODO fix this workaround to not rely on keyword
+  int coarseMultiplier = 2;
+  // variables for data logging
+  #ifdef LOG_OUT
+  std::string dirName = std::getenv("SDF3LOGDIR");
+  std::string logDirName = "dse_logs/";
+  std::string ppDirName = "pp_logs/";
+  ofstream dseLog; // save search path data in DSE log
+  std::chrono::duration<double, std::milli> cumulativeTime;
+  std::chrono::steady_clock::time_point cumulativeStart;
+  #endif
 
     /******************************************************************************
      * Bounds on the search space
@@ -62,6 +86,9 @@
      */
     void CSDFstateSpaceBufferAnalysis::initMinimalChannelSzStep(TimedCSDFgraph *g)
     {
+      #ifdef VERBOSE_OUT
+      cout << "Calculating minimal channel step sizes..." << endl;
+      #endif
         minSzStep = new TBufSize [g->nrChannels()];
 
         for (CSDFchannelsIter iter = g->channelsBegin(); iter != g->channelsEnd();
@@ -84,6 +111,10 @@
                 minStepSz = gcd(minStepSz, dstPort->getRate()[i]);
 
             minSzStep[ch->getId()] = minStepSz;
+            #ifdef VERBOSE_OUT
+            cout << "Min. step size for channel " << ch->getName() << ": "
+                 << minStepSz << endl;
+            #endif
         }
     }
 
@@ -93,6 +124,9 @@
      */
     void CSDFstateSpaceBufferAnalysis::initMinimalChannelSz(TimedCSDFgraph *g)
     {
+      #ifdef VERBOSE_OUT
+      cout << "Calculating minimal channel sizes (for positive throughput)..." << endl;
+      #endif
         minSz =  new TBufSize [g->nrChannels()];
 
         for (CSDFchannelsIter iter = g->channelsBegin(); iter != g->channelsEnd();
@@ -116,6 +150,9 @@
                 uint t = ch->getInitialTokens();
                 uint lb;
 
+                #ifdef VERBOSE_OUT
+                cout << "p, c, t: " << p << ", " << c << ", " << t << endl;
+                #endif
                 // Lower-bound of a self-edge is rate at which data is produced and
                 // consumed and the number of initial tokens present
                 if (ch->getSrcActor()->getId() == ch->getDstActor()->getId())
@@ -134,6 +171,10 @@
                 if (lb < minSz[ch->getId()])
                     minSz[ch->getId()] = lb;
             }
+            #ifdef VERBOSE_OUT
+            cout << "Minimum channel size for " << ch->getName() << ": "
+                 << minSz[ch->getId()] << endl;
+            #endif
         }
     }
 
@@ -147,6 +188,9 @@
 
         for (uint c = 0; c < g->nrChannels(); c++)
             lbDistributionSz += minSz[c];
+        #ifdef VERBOSE_OUT
+        cout << "Lower bound distribution size: " << lbDistributionSz << endl;
+        #endif
     }
 
     /**
@@ -158,6 +202,9 @@
         CSDFstateSpaceThroughputAnalysis thrAnalysisAlgo;
 
         maxThroughput = thrAnalysisAlgo.analyze(g);
+        #ifdef VERBOSE_OUT
+        cout << "Max throughput: " << maxThroughput << endl;
+        #endif
     }
 
     /******************************************************************************
@@ -350,7 +397,12 @@
             // Time between previous state
             time += s.glbClk;
         }
-
+        #ifdef DEPS_OUT
+        cout << "\nComputing throughput..."
+             << "\nNumber of executions: " << nr_fire
+             << "\nPeriod length: " << time
+             << endl;
+        #endif
         return (TDtime)(nr_fire) / (time);
     }
 
@@ -382,6 +434,10 @@
                 if (color[b] == 1)
                 {
                     // Found a cycle in the graph containing node b
+                  #ifdef DEPS_OUT
+                  cout << "\t\t\t\t Found cycle in abstract dep graph containing node from actor "
+                       << g->getActor(a)->getName() << " and actor " << g->getActor(b)->getName() << endl;
+                  #endif
                     c = a;
                     d = b;
                     do
@@ -396,7 +452,12 @@
                             CId dstId = ch->getDstActor()->getId();
 
                             if (dstId == d && srcId == c)
+                              {
+                                #ifdef DEPS_OUT
+                                cout << "\t\t\t\t  Storage dependency found in channel " << ch->getName() << endl;
+                                #endif
                                 dep[ch->getId()] = true;
+                              }
                         }
 
                         // Next
@@ -459,6 +520,121 @@
         delete [] pi;
     }
 
+      /**
+     * findStorageDependenciesSCC ()
+     * The function find all cycles in the abstract dependency graph using
+     * strongly-connected components
+     */
+    void CSDFstateSpaceBufferAnalysis::TransitionSystem
+    ::findStorageDependenciesSCC(bool **abstractDepGraph, bool *dep)
+    {
+        int *visited;
+        std::stack<int> dfsOrder;
+        std::vector<int> sccNodes;
+        int sccCount = 1;
+        std::map<int, std::vector<int>> sccMap;
+
+        // Initialize DFS data structures
+        visited = new int [g->nrActors()];
+        for (uint i = 0; i < g->nrActors(); i++)
+            visited[i] = 0;
+
+        // Initialize storage dependencies
+        for (uint c = 0; c < g->nrChannels(); c++)
+            dep[c] = false;
+
+        // DFS from every node in the graph to find all cycles
+        for (uint i = 0; i < g->nrActors(); i++)
+        {
+          if (!visited[i]) {
+            // compute dfs stack
+            computeDFSStack(i, visited, abstractDepGraph, dfsOrder);
+          }
+        }
+
+        // reset visited node list
+        for (uint i = 0; i < g->nrActors(); i++) {
+          visited[i] = 0;
+        }
+
+        // perform transpose dfs according to dfs stack
+        while (!dfsOrder.empty())
+          {
+            int firstId = dfsOrder.top();
+            dfsOrder.pop();
+            if (!visited[firstId])
+              {
+                dfsTranspose(firstId, visited, abstractDepGraph, sccNodes);
+                sccMap[sccCount] = sccNodes;
+                sccCount++;
+                sccNodes.clear();
+              }
+          }
+
+        // look for actors in the same SCC --- channel connecting them will have storage dep
+        for (CSDFchannelsIter iter = g->channelsBegin();
+             iter != g->channelsEnd(); iter++)
+          {
+            CSDFchannel *ch = *iter;
+            CId srcId = ch->getSrcActor()->getId();
+            CId dstId = ch->getDstActor()->getId();
+
+            if (abstractDepGraph[srcId][dstId])
+              {
+                for (auto const& component : sccMap)
+                  {
+                    bool srcActorInSCC = std::find(component.second.begin(),
+                                                   component.second.end(), srcId) != component.second.end();
+                    bool dstActorInSCC = std::find(component.second.begin(),
+                                                   component.second.end(), dstId) != component.second.end();
+                    if (srcActorInSCC && dstActorInSCC)
+                      {
+                        dep[ch->getId()] = true;
+                      }
+                  }
+              }
+          }
+
+        // Cleanup
+        delete [] visited;
+    }
+
+  void CSDFstateSpaceBufferAnalysis::TransitionSystem
+  ::computeDFSStack(uint startId, int *visited, bool **abstractDepGraph,
+                    std::stack<int> &dfsOrder)
+  {
+    if (visited[startId]) {
+      return;
+    }
+    visited[startId] = 1;
+    for (uint adjId = 0; adjId < g->nrActors(); adjId++)
+      {
+        if (abstractDepGraph[startId][adjId])
+          {
+            computeDFSStack(adjId, visited, abstractDepGraph, dfsOrder);
+          }
+      }
+    dfsOrder.push(startId);
+  }
+
+  void CSDFstateSpaceBufferAnalysis::TransitionSystem
+  ::dfsTranspose(uint startId, int *visited, bool **abstractDepGraph,
+                 std::vector<int> &sccNodes)
+  {
+    if (visited[startId]) {
+      return;
+    }
+    visited[startId] = 1;
+    sccNodes.push_back(startId);
+
+    for (uint adjId = 0; adjId < g->nrActors(); adjId++)
+      {
+        if (abstractDepGraph[adjId][startId])
+          {
+            dfsTranspose(adjId, visited, abstractDepGraph, sccNodes);
+          }
+      }
+  }
     /******************************************************************************
      * CSDF
      *****************************************************************************/
@@ -520,6 +696,9 @@
     void CSDFstateSpaceBufferAnalysis::TransitionSystem::startActorFiring(
         TimedCSDFactor *a)
     {
+      #ifdef DEPS_OUT
+      cout << "Start firing of actor " << a->getName() << endl;
+      #endif
         // Consume tokens from inputs and space for output tokens
         for (CSDFportsIter iter = a->portsBegin(); iter != a->portsEnd(); iter++)
         {
@@ -529,20 +708,37 @@
             // Actor is destination of the channel?
             if (p->getType() == CSDFport::In)
             {
+              #ifdef DEPS_OUT
+              cout << "\tConsume " << p->getRate()[ACT_SEQ_POS(a->getId())]
+                   << " tokens from channel " << c->getName() << endl;
+              #endif
                 CONSUME(c->getId(), p->getRate()[ACT_SEQ_POS(a->getId())]);
             }
             else
             {
-                CONSUME_SP(c->getId(), p->getRate()[ACT_SEQ_POS(a->getId())]);
+              #ifdef DEPS_OUT
+              cout << "\tSpace in channel " << c->getName() << " reduced by "
+                   << p->getRate()[ACT_SEQ_POS(a->getId())] << endl;
+              #endif
+              CONSUME_SP(c->getId(), p->getRate()[ACT_SEQ_POS(a->getId())]);
             }
         }
 
         // Add actor firing to the list of active firings of this actor
         currentState.actClk[a->getId()].push_back(
             a->getExecutionTime()[ACT_SEQ_POS(a->getId())]);
+        #ifdef DEPS_OUT
+        cout << "\t\tAdd actor firing to list of active firings of actor:" << endl;
+        cout << "\t\tExecution time of " << a->getExecutionTime()[ACT_SEQ_POS(a->getId())]
+             << " added" << endl;
+        #endif
 
         // Advance the sequence position of the actor
         ACT_SEQ_POS(a->getId()) = (ACT_SEQ_POS(a->getId()) + 1) % a->sequenceLength();
+        #ifdef DEPS_OUT
+        cout << "\t\tActor is now in phase " << ACT_SEQ_POS(a->getId()) << endl;
+        currentState.print(cout);
+        #endif
     }
 
     /**
@@ -571,6 +767,9 @@
     void CSDFstateSpaceBufferAnalysis::TransitionSystem::endActorFiring(
         CSDFactor *a)
     {
+      #ifdef DEPS_OUT
+      cout << "End firing of actor " << a->getName() << endl;
+      #endif
         for (CSDFportsIter iter = a->portsBegin(); iter != a->portsEnd(); iter++)
         {
             CSDFport *p = *iter;
@@ -584,16 +783,28 @@
             // Actor is source of the channel?
             if (p->getType() == CSDFport::Out)
             {
-                PRODUCE(c->getId(), p->getRate()[seqPos]);
+              #ifdef DEPS_OUT
+              cout << "\tProduce " << p->getRate()[seqPos]
+                   << " tokens into channel " << c->getName() << endl;
+              #endif
+              PRODUCE(c->getId(), p->getRate()[seqPos]);
             }
             else
             {
+              #ifdef DEPS_OUT
+              cout << "\tSpace in channel " << c->getName() << " increased by "
+                   << p->getRate()[seqPos] << endl;
+              #endif
                 PRODUCE_SP(c->getId(), p->getRate()[seqPos]);
             }
         }
 
         // Remove the firing from the list of active actor firings
         currentState.actClk[a->getId()].pop_front();
+        #ifdef DEPS_OUT
+        cout << "\t\tRemove actor firing to list of active firings of actor" << endl;
+        currentState.print(cout);
+        #endif
     }
 
     /**
@@ -669,6 +880,17 @@
                 if (!CH_TOKENS_PREV(c->getId(),
                                     p->getRate()[ACT_SEQ_POS(a->getId())]))
                 {
+                  #ifdef DEPS_OUT
+                  cout << "\t\t\t\tFound causal dependency in channel " << c->getName()
+                       << ": not enough tokens in previous state (needed at least "
+                       << p->getRate()[ACT_SEQ_POS(a->getId())] << " tokens)" << endl;
+                  cout << "Previous state:" << endl;
+                  previousState.print(cout);
+                  cout << endl;
+                  cout << "Current state:" << endl;
+                  currentState.print(cout);
+                  cout << endl;
+                  #endif
                     abstractDepGraph[dstActor->getId()][srcActor->getId()] = true;
                 }
             }
@@ -678,6 +900,17 @@
                 if (!CH_SPACE_PREV(c->getId(),
                                    p->getRate()[ACT_SEQ_POS(a->getId())]))
                 {
+                  #ifdef DEPS_OUT
+                  cout << "\t\t\t\tFound causal dependency in channel " << c->getName()
+                       << ": not enough space in previous state (needed at least "
+                       << p->getRate()[ACT_SEQ_POS(a->getId())] << " space)" << endl;
+                  cout << "Previous state:" << endl;
+                  previousState.print(cout);
+                  cout << endl;
+                  cout << "Current state:" << endl;
+                  currentState.print(cout);
+                  cout << endl;
+                  #endif
                     abstractDepGraph[srcActor->getId()][dstActor->getId()] = true;
                 }
             }
@@ -708,26 +941,46 @@
             for (uint j = 0; j < g->nrActors(); j++)
                 abstractDepGraph[i][j] = false;
         }
+        #ifdef DEPS_OUT
+        cout << "\t\t\tAbstract dependency graph initialised" << endl;
+        #endif
 
         // Start new iteration of the periodic phase
         currentState.glbClk = 0;
+        #ifdef DEPS_OUT
+        cout << "\t\t\tReset global clock for new iteration of periodic phase:" << endl;
+        currentState.print(cout);
+        #endif
 
         // Still need to complete the last firing of the output actor
         // before period really ends
-        repCnt = -1;
+        repCnt = -1; // so that output actor is executed one more time
 
         // Complete the remaining actor firings
+        #ifdef DEPS_OUT
+        cout << "\t\t\tCompleting remaining actor firings" << endl;
+        #endif
         for (CSDFactorsIter iter = g->actorsBegin(); iter != g->actorsEnd(); iter++)
         {
             CSDFactor *a = *iter;
 
             while (actorReadyToEnd(a))
             {
+              #ifdef DEPS_OUT
+              cout << "\n\t\t\tActor " << a->getName() << " ready to end...." << endl;
+              #endif
                 if (a->getId() == outputActor->getId())
                 {
                     repCnt++;
+                    #ifdef DEPS_OUT
+                    cout << "\t\t\tActor is output actor (has lowest rep vector value): incrementing repCnt to: "
+                         << repCnt << endl;
+                    #endif
                     if (repCnt == outputActorRepCnt)
                     {
+                      #ifdef DEPS_OUT
+                      cout << "\t\t\trepCnt equal to outputActorRepCnt: reset currentState.glbClk and repCnt to 0" << endl;
+                      #endif
                         currentState.glbClk = 0;
                         repCnt = 0;
                     }
@@ -749,6 +1002,10 @@
                 // Ready to fire actor a?
                 while (actorReadyToFire(a))
                 {
+                  #ifdef DEPS_OUT
+                  cout << "\n\t\t\tActor " << a->getName() << " ready to fire" << endl;
+                  cout << "\t\t\tFind causal dependencies for this actor" << endl;
+                  #endif
                     // Track causal dependencies on firing of actor a
                     findCausalDependencies(a, abstractDepGraph);
 
@@ -760,6 +1017,9 @@
             // Clock step
             clockStep();
 
+            #ifdef DEPS_OUT
+            cout << "\t\t\tStoring partial state by setting current state ch and sp to prev state" << endl;
+            #endif
             // Store partial state to check for progress
             for (uint i = 0; i < g->nrChannels(); i++)
             {
@@ -768,6 +1028,9 @@
             }
 
             // Finish actor firings
+            #ifdef DEPS_OUT
+            cout << "\t\t\tFinish actor firings" << endl;
+            #endif
             for (CSDFactorsIter iter = g->actorsBegin();
                  iter != g->actorsEnd(); iter++)
             {
@@ -775,14 +1038,28 @@
 
                 while (actorReadyToEnd(a))
                 {
+                  #ifdef DEPS_OUT
+                  cout << "\n\t\t\tActor " << a->getName() << " ready to end...." << endl;
+                  #endif
                     if (outputActor->getId() == a->getId())
                     {
                         repCnt++;
+                        #ifdef DEPS_OUT
+                        cout << "\t\t\tActor is output actor (has lowest rep vector value): incrementing repCnt to: "
+                             << repCnt << endl;
+                        #endif
                         if (repCnt == outputActorRepCnt)
                         {
+                          #ifdef DEPS_OUT
+                          cout << "\t\t\trepCnt equal to outputActorRepCnt:" << endl;
+                          #endif
                             // Found periodic state
                             if (currentState == periodicState)
                             {
+                              #ifdef DEPS_OUT
+                              cout << "\t\t\tCurrent state is the periodic state" << endl;
+                              cout << "\t\t\t\tLook for storage dependencies (cycles in abstract dependency graph)" << endl;
+                              #endif
                                 // Cycles in the dependency graph indicate storage
                                 // dependencies
                                 findStorageDependencies(abstractDepGraph, dep);
@@ -795,6 +1072,9 @@
                                 // Done
                                 return;
                             }
+                            #ifdef DEPS_OUT
+                            cout << "Reset currentState.glbClk and repCnt to 0" << endl;
+                            #endif
                             currentState.glbClk = 0;
                             repCnt = 0;
                         }
@@ -824,6 +1104,9 @@
             for (uint j = 0; j < g->nrActors(); j++)
                 abstractDepGraph[i][j] = false;
         }
+        #ifdef DEPS_OUT
+        cout << "\tAbstract dependency graph initialised" << endl;
+        #endif
 
         // Check number of tokens on every channel in the graph
         for (CSDFchannelsIter iter = g->channelsBegin();
@@ -837,6 +1120,12 @@
             if (!CH_TOKENS(c->getId(),
                            c->getDstPort()->getRate()[ACT_SEQ_POS(dstActor->getId())]))
             {
+              #ifdef DEPS_OUT
+              cout << "\t\tFound causal dependency in channel " << c->getName()
+                   << ": not enough tokens to fire destination actor " << dstActor->getName()
+                   << " (needed at least " << c->getDstPort()->getRate()[ACT_SEQ_POS(dstActor->getId())]
+                   << " tokens)" << endl;
+              #endif
                 abstractDepGraph[dstActor->getId()][srcActor->getId()] = true;
             }
 
@@ -844,6 +1133,12 @@
             if (!CH_SPACE(c->getId(),
                           c->getSrcPort()->getRate()[ACT_SEQ_POS(srcActor->getId())]))
             {
+              #ifdef DEPS_OUT
+              cout << "\t\tFound causal dependency in channel " << c->getName()
+                   << ": not enough space to fire source actor " << srcActor->getName()
+                   << " (needed at least " << c->getSrcPort()->getRate()[ACT_SEQ_POS(dstActor->getId())]
+                   << " space)" << endl;
+              #endif
                 abstractDepGraph[srcActor->getId()][dstActor->getId()] = true;
             }
         }
@@ -873,6 +1168,10 @@
         clearStoredStates();
 
         // Create initial state
+        #ifdef DEPS_OUT
+        cout << "Initialising previous and current states with " << std::to_string(g->nrActors())
+             << " actors and " << std::to_string(g->nrChannels()) << " channels" << endl;
+        #endif
         currentState.init(g->nrActors(), g->nrChannels());
         currentState.clear();
         previousState.init(g->nrActors(), g->nrChannels());
@@ -891,11 +1190,22 @@
                 return 0;
             }
 
+            #ifdef DEPS_OUT
+            cout << "Setting initial tokens and space for channel: " << c->getName() << " ("
+                 << c->getInitialTokens() << ", " << sp[c->getId()] - c->getInitialTokens()
+                 << ")" << endl;
+            #endif
             CH(c->getId()) = c->getInitialTokens();
             SP(c->getId()) = sp[c->getId()] - c->getInitialTokens();
+            #ifdef DEPS_OUT
+            c->print(cout);
+            #endif
         }
 
         // Fire the actors
+        #ifdef DEPS_OUT
+        cout << "\nBegin actor firings" << endl;
+        #endif
         while (true)
         {
             // Store partial state to check for progress
@@ -913,15 +1223,28 @@
 
                 while (actorReadyToEnd(a))
                 {
+                  #ifdef DEPS_OUT
+                  cout << "\nActor " << a->getName() << " ready to end...." << endl;
+                  #endif
                     if (outputActor->getId() == a->getId())
                     {
                         repCnt++;
+                        #ifdef DEPS_OUT
+                        cout << "\tActor is output actor (has lowest rep vector value): incrementing repCnt to: "
+                             << repCnt << endl;
+                        #endif
                         if (repCnt == outputActorRepCnt)
                         {
+                          #ifdef DEPS_OUT
+                          cout << "\t\trepCnt equal to outputActorRepCnt" << endl;
+                          #endif
                             // Add state to hash of visited states
                             if (!storeState(currentState, recurrentState))
                             {
-                                // Find storage dependencies in periodic phase
+                              // Find storage dependencies in periodic phase
+                              #ifdef DEPS_OUT
+                              cout << "\t\tCurrent state has been visited before: analyse periodic phase" << endl;
+                              #endif
                                 analyzePeriodicPhase(sp, dep);
 
                                 return computeThroughput(recurrentState);
@@ -945,6 +1268,9 @@
                 // Ready to fire actor a?
                 while (actorReadyToFire(a))
                 {
+                  #ifdef DEPS_OUT
+                  cout << "\nActor " << a->getName() << " ready to fire" << endl;
+                  #endif
                     // Fire actor a
                     startActorFiring(a);
                 }
@@ -952,10 +1278,16 @@
 
             // Clock step
             clkStep = clockStep();
+            #ifdef DEPS_OUT
+            cout << "clkStep set to " << clkStep << endl;
+            #endif
 
             // Deadlocked?
             if (clkStep == UINT_MAX)
             {
+              #ifdef DEPS_OUT
+              cout << "clkStep too high, deadlock found: analyse deadlock" << endl;
+              #endif
                 // Find cause of deadlock
                 analyzeDeadlock(sp, dep);
                 return 0;
@@ -1015,6 +1347,46 @@
         //for (uint c = 0; c < g->nrChannels(); c++)
         //    cerr << d->sp[c] << " " << d->dep[c] << endl;
         //cerr << endl;
+
+        #ifdef VERBOSE_OUT
+        cout << "\tCurrent StorageDistribution info:" << endl;
+        cout << "\tNumber of edges: " << g->nrChannels() << endl;
+        cout << "\tChannel quantities:\n\t";
+        for (CSDFchannelsIter iter = g->channelsBegin();
+             iter != g->channelsEnd(); iter++) {
+          CSDFchannel *c = *iter;
+          if (c->getSrcActor()->getId() != c->getDstActor()->getId()) { // ignore feedback edges
+            cout << d->sp[c->getId()] << " ";
+          }
+        }
+        cout << endl;
+        cout << "\tDistribution size: " << d->sz << endl;
+        cout << "\tThroughput: " << d->thr << endl;
+        cout << endl;
+        #endif
+
+        #ifdef LOG_OUT
+        // log dse data
+        std::string output("\"");
+        std::string delim("");
+        std::string colDelim(";");
+        uint noFeedbackSize = 0;
+        for (CSDFchannelsIter iter = g->channelsBegin();
+             iter != g->channelsEnd(); iter++) {
+          CSDFchannel *c = *iter;
+          if (c->getSrcActor()->getId() != c->getDstActor()->getId()) { // ignore feedback edges
+            output += delim;
+            output += std::to_string(d->sp[c->getId()]);
+            delim = ",";
+            noFeedbackSize += d->sp[c->getId()];
+          }
+        }
+        output += "\"";
+
+        dseLog << noFeedbackSize << colDelim // distribution size
+               << d->thr << colDelim // throughput
+               << output << colDelim; // channel quantities
+        #endif
     }
 
     /**
@@ -1032,6 +1404,10 @@
         // throughput with previous (smaller) distribution size
         if (ds->prev != NULL && ds->prev->thr == ds->thr)
         {
+          #ifdef VERBOSE_OUT
+          cout << "\t\tNew storage distribution set of dist size " << ds->sz
+               << " found to be non-minimal: removing from set" << endl;
+          #endif
             // No minimal storage distributions exist in this list
             // Iterate over the list of storage distributions
             d = ds->distributions;
@@ -1072,6 +1448,10 @@
                     t = d->next;
 
                     // Cleanup d
+                    #ifdef VERBOSE_OUT
+                    cout << "\t\tStorage distribution of size " << d->sz
+                         << " found to be non-minimal: removing from set" << endl;
+                    #endif
                     deleteStorageDistribution(d);
 
                     // Next
@@ -1102,9 +1482,16 @@
         StorageDistribution *di;
         bool equalDistr;
 
+        #ifdef VERBOSE_OUT
+        cout << "\t\tAttempting to add storage distribution of dist sz: " << d->sz
+             << " to set" << endl;
+        #endif
         // First distribution ever added?
         if (minStorageDistributions == NULL)
         {
+          #ifdef VERBOSE_OUT
+          cout << "\t\t\tFirst of this distribution size: adding new distribution" << endl;
+          #endif
             // Create new set of storage distributions
             dsNew = new StorageDistributionSet;
             dsNew->sz = d->sz;
@@ -1147,14 +1534,21 @@
                 }
 
                 // Found equal distribution
-                if (equalDistr)
-                    return false;
+                if (equalDistr) {
+                  #ifdef VERBOSE_OUT
+                  cout << "\t\t\tFound matching distribution: not adding new distribution" << endl;
+                  #endif
+                  return false;
+                }
 
                 // Next
                 di = di->next;
             }
 
             // Distribution 'd' not yet in the set, so let's add it
+            #ifdef VERBOSE_OUT
+            cout << "\t\t\tNew storage distribution added!" << endl;
+            #endif
             ds->distributions->prev = d;
             d->next = ds->distributions;
             ds->distributions = d;
@@ -1162,7 +1556,9 @@
         else if (ds->next == NULL)
         {
             // No set of distribution in the list with same or larger size?
-
+          #ifdef VERBOSE_OUT
+          cout << "\t\t\tFirst of this distribution size: adding new distribution" << endl;
+          #endif
             // Create new set of storage distributions
             dsNew = new StorageDistributionSet;
             dsNew->sz = d->sz;
@@ -1182,6 +1578,9 @@
             // distribution 'd'.
 
             // Create new set of storage distributions
+          #ifdef VERBOSE_OUT
+          cout << "\t\t\tFirst of this distribution size: adding new distribution" << endl;
+          #endif
             dsNew = new StorageDistributionSet;
             dsNew->sz = d->sz;
             dsNew->thr = 0;
@@ -1211,13 +1610,28 @@
     {
         StorageDistribution *dNew;
 
+        #ifdef LOG_OUT
+        auto startTime = std::chrono::steady_clock::now();
+        #endif
         // Compute throughput and storage dependencies
         execStorageDistribution(d);
+        #ifdef LOG_OUT
+        auto endTime = std::chrono::steady_clock::now();
+        std::chrono::duration<double, std::milli> execTime = endTime - startTime; // duration of individual execution
+        #endif
+        #ifdef VERBOSE_OUT
+        computation_counter++;
+        #endif
 
         // Throughput of d larger then current maximum of the set
         if (d->thr > ds->thr)
             ds->thr = d->thr;
 
+        #ifdef LOG_OUT
+        // log execution times (cont. from execStorageDistribution)
+        dseLog << execTime.count() << ";";
+        #endif
+
         // Create new storage distributions for every channel which
         // has a storage dependency in d
         for (uint c = 0; c < g->nrChannels(); c++)
@@ -1225,25 +1639,48 @@
             // Channel c has storage dependency?
             if (d->dep[c])
             {
+              #ifdef VERBOSE_OUT
+              cout << "\tFound storage dependency in channel " << g->getChannel(c)->getName() << endl;
+              #endif
                 // Do not enlarge the channel if its a self-edge
                 if (g->getChannel(c)->getSrcActor()->getId()
-                    == g->getChannel(c)->getDstActor()->getId())
-                    continue;
+                    == g->getChannel(c)->getDstActor()->getId()) {
+                  #ifdef VERBOSE_OUT
+                  cout << "\t\tChannel " << g->getChannel(c)->getName() << " is a self-edge: ignoring" << endl;
+                  #endif
+                  continue;
+                }
 
                 // Create new storage distribution with channel c enlarged
                 dNew = newStorageDistribution();
-                dNew->sz = d->sz + minSzStep[c];
+                if (!useCoarse) {
+                  dNew->sz = d->sz + minSzStep[c];
+                } else {
+                  dNew->sz = d->sz + minSzStep[c] * coarseMultiplier;
+                }
                 dNew->thr = 0;
                 for (uint i = 0; i < g->nrChannels(); i++)
                 {
                     dNew->sp[i] = d->sp[i];
-                    if (i == c)
+                    if (i == c) {
+                      if (!useCoarse) {
                         dNew->sp[i] += minSzStep[c];
+                      } else {
+                        dNew->sp[i] += minSzStep[c] * coarseMultiplier;
+                      }
+                      #ifdef VERBOSE_OUT
+                      cout << "\t\tIncreasing channel size of " << g->getChannel(c)->getName()
+                           << " to " << dNew->sp[i] << endl;
+                      #endif
+                    }
                 }
                 dNew->next = NULL;
                 dNew->prev = NULL;
 
                 // Add storage distribution to set of distributions to be checked
+                #ifdef VERBOSE_OUT
+                cout << "\tUpdating checklist with new storage distribution..." << endl;
+                #endif
                 if (!addStorageDistributionToChecklist(dNew))
                 {
                     // Distribution already in check list
@@ -1251,6 +1688,11 @@
                 }
             }
         }
+        #ifdef LOG_OUT
+        // update cumulative duration since start of DSE
+        cumulativeTime = std::chrono::steady_clock::now() - cumulativeStart;
+        dseLog << cumulativeTime.count() << endl;
+        #endif
     }
 
     /**
@@ -1267,6 +1709,9 @@
         d = ds->distributions;
         while (d != NULL)
         {
+          #ifdef VERBOSE_OUT
+          cout << "\nExploring new storage distribution:" << endl;
+          #endif
             // Explore distribution d
             exploreStorageDistribution(ds, d);
 
@@ -1275,6 +1720,10 @@
         }
 
         // Remove all non-minimal storage distributions from the set
+        #ifdef VERBOSE_OUT
+        cout << "\tTrying to minimise set with distribution size: "
+             << ds->sz << endl;
+        #endif
         minimizeStorageDistributionsSet(ds);
     }
 
@@ -1305,6 +1754,26 @@
         // Check sets of storage distributions till no distributions left to check,
         // or throughput bound exceeded, or maximal throughput reached
         ds = minStorageDistributions;
+
+        // Initialise log file
+        #ifdef LOG_OUT
+        std::string dseMethodName;
+        if (useSCCStorageDeps) {
+          dseMethodName = "_dselog_sdf3_corrected";
+        } else {
+          dseMethodName = "_dselog_sdf3";
+        }
+        if (useCoarse) {
+          dseMethodName += "_coarse";
+        }
+        dseLog.open(dirName + logDirName + g->getName() + dseMethodName + ".csv");
+        dseLog << "storage distribution size;throughput;channel quantities;computation duration;cumulative duration"
+               << endl; // initialise headers
+        #endif
+
+        #ifdef VERBOSE_OUT
+        cout << "DSE BEGIN:" << endl;
+        #endif
         while (ds != NULL)
         {
             // Explore all distributions with size 'ds->sz'
@@ -1390,6 +1859,83 @@
             for (uint c = 0; c < g->nrChannels(); c++)
                 minStorageDistributions->distributions->sp[c] = 0;
         }
+
+        // print DSE results
+        #ifdef VERBOSE_OUT
+        long int pp_counter = 0;
+        cout << "\nDSE RESULTS [START] (target throughput: " << maxThroughput
+             << "):" << endl;
+
+        for (StorageDistributionSet *p = minStorageDistributions; p != NULL;
+             p = p->next) {
+          cout << "Printing storage distributions of distribution size: "
+               << p->sz << endl;
+          for (StorageDistribution *d = p->distributions; d != NULL;
+               d = d->next) {
+            pp_counter++;
+            cout << "\tCurrent StorageDistribution info:" << endl;
+            cout << "\tNumber of edges: " << g->nrChannels() << endl;
+            cout << "\tChannel quantities:\n\t";
+            for (uint c = 0; c < g->nrChannels(); c++) {
+              if (g->getChannel(c)->getSrcActor()->getId() !=
+                  g->getChannel(c)->getDstActor()->getId()) {
+                cout << d->sp[g->getChannel(c)->getId()] << " ";
+              }
+            }
+            cout << endl;
+            cout << "\tDistribution size: " << d->sz << endl;
+            cout << "\tThroughput: " << d->thr << endl;
+          }
+        }
+        cout << "DSE RESULTS [END]" << endl;
+        cout << "Done with search!" << endl;
+        cout << "Number of computations: " << computation_counter << endl;
+        cout << "Number of pareto points: " << pp_counter << endl;
+        #endif
+
+        #ifdef LOG_OUT
+        dseLog.close(); // DSE logging ends at this point
+        // Variables for pareto point logging
+        ofstream ppLog;
+        std::string ppMethodName;
+        if (useSCCStorageDeps) {
+          ppMethodName = "_pp_sdf3_corrected";
+        } else {
+          ppMethodName = "_pp_sdf3";
+        }
+        if (useCoarse) {
+          ppMethodName += "_coarse";
+        }
+        ppLog.open(dirName + ppDirName + g->getName() + ppMethodName + ".csv");
+        // Initialise log file
+        ppLog << "storage distribution size;throughput;channel quantities" << endl;
+
+        for (StorageDistributionSet *p = minStorageDistributions; p != NULL;
+             p = p->next) {
+          for (StorageDistribution *d = p->distributions; d != NULL;
+               d = d->next) {
+            std::string output("\"");
+            std::string delim("");
+            std::string colDelim(";");
+            uint noFeedbackSize = 0;
+            for (uint c = 0; c < g->nrChannels(); c++) {
+              if (g->getChannel(c)->getSrcActor()->getId() !=
+                  g->getChannel(c)->getDstActor()->getId()) {
+                output += delim;
+                output += std::to_string(d->sp[g->getChannel(c)->getId()]);
+                delim = ",";
+                noFeedbackSize += d->sp[g->getChannel(c)->getId()];
+              }
+            }
+            output += "\"";
+            ppLog << noFeedbackSize << colDelim
+                  << d->thr << colDelim
+                  << output << endl;
+          }
+        }
+        ppLog.close();
+        #endif
+
     }
 
     /**
@@ -1409,6 +1955,12 @@
         minStorageDistributions = NULL;
 
         // Initialize bounds on the search space
+        #ifdef VERBOSE_OUT
+        cout << "INITIALISING SEARCH PARAMETERS:" << endl;
+        #endif
+        #ifdef LOG_OUT
+        cumulativeStart = std::chrono::steady_clock::now(); // DSE cumulative time starts here
+        #endif
         initBoundsSearchSpace(g);
 
         // Create a transition system
diff -ruN sdf3_140724/sdf3/csdf/analysis/buffersizing/buffer.h sdf3_custom/sdf3/csdf/analysis/buffersizing/buffer.h
--- sdf3_140724/sdf3/csdf/analysis/buffersizing/buffer.h	2014-07-24 12:16:04.000000000 +0800
+++ sdf3_custom/sdf3/csdf/analysis/buffersizing/buffer.h	2022-04-13 21:25:58.259736324 +0800
@@ -40,6 +40,7 @@
 
 #include "sdf/sdf.h"
 #include "../../base/timed/graph.h"
+#include <stack>
 namespace CSDF
 {
     /**
@@ -154,6 +155,13 @@
                     void findCausalDependencies(CSDFactor *a, bool **abstractDepGraph);
                     void analyzePeriodicPhase(const TBufSize *sp, bool *dep);
                     void analyzeDeadlock(const TBufSize *sp, bool *dep);
+                    void findStorageDependenciesSCC(bool **abstractDepGraph, bool *dep);
+                    void computeDFSStack(uint startId, int *visited,
+                                         bool **abstractDepGraph,
+                                         std::stack<int> &dfsOrder);
+                    void dfsTranspose(uint startId, int *visited,
+                                      bool **abstractDepGraph,
+                                      std::vector<int> &sccNodes);
 
                     // Compute throughput from transition system
                     TDtime computeThroughput(const StatesIter cycleIter);
diff -ruN sdf3_140724/sdf3/csdf/analysis/throughput/selftimed_throughput.cc sdf3_custom/sdf3/csdf/analysis/throughput/selftimed_throughput.cc
--- sdf3_140724/sdf3/csdf/analysis/throughput/selftimed_throughput.cc	2014-07-24 12:16:04.000000000 +0800
+++ sdf3_custom/sdf3/csdf/analysis/throughput/selftimed_throughput.cc	2022-04-13 21:25:58.259736324 +0800
@@ -38,7 +38,7 @@
 
 namespace CSDF
 {
-    //#define _PRINT_STATESPACE
+  //#define _PRINT_STATESPACE
 
     /******************************************************************************
      * State
@@ -116,6 +116,39 @@
             CSDFchannel *c = *iter;
             this->ch[c->getId()] = c->getInitialTokens();
         }
+        // close log file
+#ifdef LOG_OUT
+	dseLog.close();
+	// Variables for pareto point logging
+	ofstream ppLog;
+	ppLog.open(dirName + ppDirName + g->getName() + "_pp_sdf3.csv");
+	// Initialise log file
+	ppLog << "storage distribution size,throughput,channel quantities" << endl;
+
+	for (StorageDistributionSet *p = minStorageDistributions; p != NULL;
+	     p = p->next) {
+	  for (StorageDistribution *d = p->distributions; d != NULL;
+	       d = d->next) {
+	    std::string output("\"");
+	    std::string delim("");
+	    uint noFeedbackSize = 0;
+	    for (uint c = 0; c < g->nrChannels(); c++) {
+	      if (g->getChannel(c)->getSrcActor()->getId() !=
+		  g->getChannel(c)->getDstActor()->getId()) {
+		output += delim;
+		output += std::to_string(d->sp[g->getChannel(c)->getId()]);
+		delim = ",";
+		noFeedbackSize += d->sp[g->getChannel(c)->getId()];
+	      }
+	    }
+	    output += "\"";
+	    ppLog << noFeedbackSize << ","
+		  << d->thr << ","
+		  << output << endl;
+	  }
+	}
+	ppLog.close();
+#endif
     }
 
     /**
@@ -175,6 +208,10 @@
                 a = *iter;
                 min = repVec[a->getId()];
             }
+	    #ifdef VERBOSE_OUT
+	    cout << "Minimum channel size for " << ch->getName() << ": "
+		 << minSz[ch->getId()] << endl;
+	    #endif
         }
 
         // Set output actor and its repetition vector count
@@ -239,7 +276,12 @@
             // Time between previous state
             time += s.glbClk;
         }
-
+	#ifdef DEPS_OUT
+	cout << "\nComputing throughput..."
+	     << "\nNumber of executions: " << nr_fire
+	     << "\nPeriod length: " << time
+	     << endl;
+	#endif
         return (TDtime)(nr_fire) / (time);
     }
 
@@ -332,6 +374,9 @@
     void CSDFstateSpaceThroughputAnalysis::TransitionSystem::startActorFiring(
         State *s, TimedCSDFactor *a)
     {
+      #ifdef DEPS_OUT
+      cout << "Start firing of actor " << a->getName() << endl;
+      #endif
         // Consume tokens from inputs and space for output tokens
         for (CSDFportsIter iter = a->portsBegin(); iter != a->portsEnd(); iter++)
         {
@@ -510,6 +555,9 @@
             }
 
             // Finish actor firings
+	    #ifdef DEPS_OUT
+	    cout << "\t\t\tFinish actor firings" << endl;
+	    #endif
             for (CSDFactorsIter iter = g->actorsBegin();
                  iter != g->actorsEnd(); iter++)
             {
@@ -523,7 +571,7 @@
                         if (repCnt == outputActorRepCnt)
                         {
 #ifdef _PRINT_STATESPACE
-                            printState(currentState, cout);
+                            currentState.print(cout);
 #endif
                             // Add state to hash of visited states
                             if (!storeState(currentState, recurrentState))
@@ -533,6 +581,9 @@
 #endif
                                 return computeThroughput(recurrentState);
                             }
+			    #ifdef DEPS_OUT
+			    cout << "Reset currentState.glbClk and repCnt to 0" << endl;
+			    #endif
                             currentState.glbClk = 0;
                             repCnt = 0;
                         }
@@ -569,6 +620,9 @@
                 return 0;
             }
         }
+	#ifdef DEPS_OUT
+	cout << "\tAbstract dependency graph initialised" << endl;
+	#endif
 
         return 0;
     }
diff -ruN sdf3_140724/sdf3/csdf/analysis/throughput/selftimed_throughput.cc.orig sdf3_custom/sdf3/csdf/analysis/throughput/selftimed_throughput.cc.orig
--- sdf3_140724/sdf3/csdf/analysis/throughput/selftimed_throughput.cc.orig	1970-01-01 07:30:00.000000000 +0730
+++ sdf3_custom/sdf3/csdf/analysis/throughput/selftimed_throughput.cc.orig	2022-04-13 21:25:58.259736324 +0800
@@ -0,0 +1,688 @@
+/*
+ *  TU Eindhoven
+ *  Eindhoven, The Netherlands
+ *
+ *  Name            :   selftimed_throughput.cc
+ *
+ *  Author          :   Sander Stuijk (sander@ics.ele.tue.nl)
+ *
+ *  Date            :   October 10, 2007
+ *
+ *  Function        :   State-space based throughput analysis
+ *
+ *  History         :
+ *      10-10-07    :   Initial version.
+ *
+ * $Id: selftimed_throughput.cc,v 1.1.2.3 2010-07-29 20:34:08 mgeilen Exp $
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * In other words, you are welcome to use, share and improve this program.
+ * You are forbidden to forbid anyone else to use, share and improve
+ * what you give them.   Happy coding!
+ */
+
+#include "selftimed_throughput.h"
+#include "../../base/algo/components.h"
+
+namespace CSDF
+{
+  //#define _PRINT_STATESPACE
+
+    /******************************************************************************
+     * State
+     *****************************************************************************/
+
+    /**
+     * printState ()
+     * Print the state to the supplied stream.
+     */
+    void CSDFstateSpaceThroughputAnalysis::TransitionSystem::State::print(
+        ostream &out)
+    {
+        out << "### State ###" << endl;
+
+        for (uint i = 0; i < actSeqPos.size(); i++)
+        {
+            out << "actSeqPos[" << i << "] =" << actSeqPos[i] << endl;
+        }
+
+        for (uint i = 0; i < actClk.size(); i++)
+        {
+            out << "actClk[" << i << "] =";
+
+            for (list<CSDFtime>::const_iterator iter = actClk[i].begin();
+                 iter != actClk[i].end(); iter++)
+            {
+                out << " " << (*iter) << ", ";
+            }
+
+            out << endl;
+        }
+
+        for (uint i = 0; i < ch.size(); i++)
+        {
+            out << "ch[" << i << "] = " << ch[i] << endl;
+        }
+
+        out << "glbClk = " << glbClk << endl;
+    }
+
+    /**
+     * clearState ()
+     * The function sets the state to zero.
+     */
+    void CSDFstateSpaceThroughputAnalysis::TransitionSystem::State::clear()
+    {
+        for (uint i = 0; i < actSeqPos.size(); i++)
+        {
+            actSeqPos[i] = 0;
+        }
+
+        for (uint i = 0; i < actClk.size(); i++)
+        {
+            actClk[i].clear();
+        }
+
+        for (uint i = 0; i < ch.size(); i++)
+        {
+            ch[i] = 0;
+        }
+
+        glbClk = 0;
+    }
+
+
+    /**
+     * setInitialTokens ()
+     * The function sets the initial tokens on the channels.
+     */
+    void CSDFstateSpaceThroughputAnalysis::TransitionSystem::State::setInitialTokens(const TimedCSDFgraph &g)
+    {
+        for (CSDFchannelsCIter iter = g.channelsBegin();
+             iter != g.channelsEnd(); iter++)
+        {
+            CSDFchannel *c = *iter;
+            this->ch[c->getId()] = c->getInitialTokens();
+        }
+    }
+
+    /**
+     * operator== ()
+     * The function compares to states and returns true if they are equal.
+     */
+    bool CSDFstateSpaceThroughputAnalysis::TransitionSystem::State::operator==(
+        const State &s)
+    {
+        if (glbClk != s.glbClk)
+            return false;
+
+        for (uint i = 0; i < actSeqPos.size(); i++)
+        {
+            if (actSeqPos[i] != s.actSeqPos[i])
+                return false;
+        }
+
+        for (uint i = 0; i < ch.size(); i++)
+        {
+            if (ch[i] != s.ch[i])
+                return false;
+        }
+
+        for (uint i = 0; i < actClk.size(); i++)
+        {
+            if (actClk[i] != s.actClk[i])
+                return false;
+        }
+
+        return true;
+    }
+
+    /******************************************************************************
+     * Transition system
+     *****************************************************************************/
+
+    /**
+     * initOutputActor ()
+     * The function selects an actor to be used as output actor in the
+     * state transition system.
+     */
+    void CSDFstateSpaceThroughputAnalysis::TransitionSystem::initOutputActor()
+    {
+        CSDFgraph::RepetitionVector repVec;
+        int min = INT_MAX;
+        CSDFactor *a = NULL;
+
+        // Compute repetition vector
+        repVec = g->getRepetitionVector();
+
+        // Select actor with lowest entry in repetition vector as output actor
+        for (CSDFactorsIter iter = g->actorsBegin(); iter != g->actorsEnd(); iter++)
+        {
+            if (repVec[(*iter)->getId()] < min)
+            {
+                a = *iter;
+                min = repVec[a->getId()];
+            }
+	    #ifdef VERBOSE_OUT
+	    cout << "Minimum channel size for " << ch->getName() << ": "
+		 << minSz[ch->getId()] << endl;
+	    #endif
+        }
+
+        // Set output actor and its repetition vector count
+        outputActor = a->getId();
+        outputActorRepCnt = repVec[outputActor];
+    }
+
+    /**
+     * storeState ()
+     * The function stores the state s on whenever s is not already in the
+     * list of storedStates. When s is stored, the function returns true. When the
+     * state s is already in the list, the state s is not stored. The function
+     * returns false. The function always sets the pos variable to the position
+     * where the state s is in the list.
+     */
+    bool CSDFstateSpaceThroughputAnalysis::TransitionSystem::storeState(State &s,
+            StatesIter &pos)
+    {
+        // Find state in the list of stored states
+        for (StatesIter iter = storedStates.begin();
+             iter != storedStates.end(); iter++)
+        {
+            State &x = *iter;
+
+            // State s at position iter in the list?
+            if (x == s)
+            {
+                pos = iter;
+                return false;
+            }
+        }
+
+        // State not found, store it at the end of the list
+        storedStates.push_back(s);
+
+        // Added state to the end of the list
+        pos = storedStates.end();
+
+        return true;
+    }
+
+    /**
+     * computeThroughput ()
+     * The function calculates the throughput of the states on the cycle. Its
+     * value is equal to the average number of firings of an actor per time unit.
+     */
+    TDtime CSDFstateSpaceThroughputAnalysis::TransitionSystem::computeThroughput(
+        const StatesIter cycleIter)
+    {
+        int nr_fire = 0;
+        TDtime time = 0;
+
+        // Check all state from stack till cycle complete
+        for (StatesIter iter = cycleIter; iter != storedStates.end(); iter++)
+        {
+            State &s = *iter;
+
+            // Number of states in cycle is equal to number of iterations
+            // in the period
+            nr_fire++;
+
+            // Time between previous state
+            time += s.glbClk;
+        }
+	#ifdef DEPS_OUT
+	cout << "\nComputing throughput..."
+	     << "\nNumber of executions: " << nr_fire
+	     << "\nPeriod length: " << time
+	     << endl;
+	#endif
+        return (TDtime)(nr_fire) / (time);
+    }
+
+    /******************************************************************************
+     * CSDF
+     *****************************************************************************/
+
+#define CH(c)               currentState.ch[c]
+#define CH_S(s,c)           s->ch[c]
+#define CH_TOKENS(c,n)      (CH(c) >= n)
+#define CONSUME(c,n)        CH(c) = CH(c) - n;
+#define CONSUME_S(s,c,n)    CH_S(s,c) = CH_S(s,c) - n;
+#define PRODUCE(c,n)        CH(c) = CH(c) + n;
+#define PRODUCE_S(s,c,n)    CH_S(s,c) = CH_S(s,c) + n;
+
+#define CH_TOKENS_PREV(c,n) (previousState.ch[c] >= n)
+
+#define ACT_SEQ_POS(a)      currentState.actSeqPos[a]
+#define ACT_SEQ_POS_S(s,a)  s->actSeqPos[a]
+
+    /**
+     * actorReadyToFire ()
+     * The function returns true when the actor is ready to fire in state
+     * s. Else it returns false.
+     */
+    bool CSDFstateSpaceThroughputAnalysis::TransitionSystem::actorReadyToFire(
+        CSDFactor *a)
+    {
+        return this->actorReadyToFire(currentState, a);
+    }
+
+    /**
+     * actorReadyToFire ()
+     * The function returns true when the actor is ready to fire in state
+     * s. Else it returns false.
+     */
+    bool CSDFstateSpaceThroughputAnalysis::TransitionSystem::actorReadyToFire(
+        const State &s, CSDFactor *a)
+    {
+        // Check all input ports for tokens
+        for (CSDFportsIter iter = a->portsBegin(); iter != a->portsEnd(); iter++)
+        {
+            CSDFport *p = *iter;
+            CSDFchannel *c = p->getChannel();
+
+            // Actor is destination of the channel?
+            if (p->getType() == CSDFport::In)
+            {
+                if (s.ch[c->getId()] < p->getRate()[s.actSeqPos[a->getId()]])
+                {
+                    return false;
+                }
+            }
+        }
+
+        return true;
+    }
+
+
+    void CSDFstateSpaceThroughputAnalysis::TransitionSystem::fireActor(State *s, TimedCSDFactor *a)
+    {
+        startActorFiring(s, a);
+        endActorFiring(s, a);
+    }
+
+
+
+    /**
+     * startActorFiring ()
+     * Start the actor firing. Remove tokens from all input channels and add the
+     * actor firing to the list of active actor firings and advance sequence
+     * position.
+     */
+    void CSDFstateSpaceThroughputAnalysis::TransitionSystem::startActorFiring(
+        TimedCSDFactor *a)
+    {
+        this->startActorFiring(&currentState, a);
+
+#ifdef _PRINT_STATESPACE
+        cout << "start: " << a->getName() << endl;
+#endif
+    }
+
+    /**
+     * startActorFiring ()
+     * Start the actor firing. Remove tokens from all input channels and add the
+     * actor firing to the list of active actor firings and advance sequence
+     * position.
+     */
+    void CSDFstateSpaceThroughputAnalysis::TransitionSystem::startActorFiring(
+        State *s, TimedCSDFactor *a)
+    {
+      #ifdef DEPS_OUT
+      cout << "Start firing of actor " << a->getName() << endl;
+      #endif
+        // Consume tokens from inputs and space for output tokens
+        for (CSDFportsIter iter = a->portsBegin(); iter != a->portsEnd(); iter++)
+        {
+            CSDFport *p = *iter;
+            CSDFchannel *c = p->getChannel();
+
+            // Actor is destination of the channel?
+            if (p->getType() == CSDFport::In)
+            {
+                CONSUME_S(s, c->getId(), p->getRate()[ACT_SEQ_POS_S(s, a->getId())]);
+            }
+        }
+
+        // Add actor firing to the list of active firings of this actor
+        s->actClk[a->getId()].push_back(
+            a->getExecutionTime()[ACT_SEQ_POS_S(s, a->getId())]);
+
+        // Advance the sequence position of the actor
+        ACT_SEQ_POS_S(s, a->getId()) = (ACT_SEQ_POS_S(s, a->getId()) + 1) % a->sequenceLength();
+    }
+
+
+    /**
+     * actorReadyToEnd ()
+     * The function returns true when the actor is ready to end its firing. Else
+     * the function returns false.
+     */
+    bool CSDFstateSpaceThroughputAnalysis::TransitionSystem::actorReadyToEnd(
+        CSDFactor *a)
+    {
+        if (currentState.actClk[a->getId()].empty())
+            return false;
+
+        // First actor firing in sorted list has execution time left?
+        if (currentState.actClk[a->getId()].front() != 0)
+            return false;
+
+        return true;
+    }
+
+    /**
+     * endActorFiring ()
+     * Produce tokens on all output channels and remove the actor firing from the
+     * list of active firings.
+     */
+    void CSDFstateSpaceThroughputAnalysis::TransitionSystem::endActorFiring(
+        CSDFactor *a)
+    {
+        this->endActorFiring(&currentState, a);
+
+#ifdef _PRINT_STATESPACE
+        cout << "end:   " << a->getName() << endl;
+#endif
+    }
+
+    /**
+     * endActorFiring ()
+     * Produce tokens on all output channels and remove the actor firing from the
+     * list of active firings.
+     */
+    void CSDFstateSpaceThroughputAnalysis::TransitionSystem::endActorFiring(
+        State *s, CSDFactor *a)
+    {
+        int seqPos;
+
+        for (CSDFportsIter iter = a->portsBegin(); iter != a->portsEnd(); iter++)
+        {
+            CSDFport *p = *iter;
+            CSDFchannel *c = p->getChannel();
+
+            // Actor is source of the channel?
+            if (p->getType() == CSDFport::Out)
+            {
+                // Position in the sequence to which this end corresponds
+                seqPos = ACT_SEQ_POS_S(s, a->getId())
+                         - s->actClk[a->getId()].size();
+
+                // Produce the tokens
+                PRODUCE_S(s, c->getId(), p->getRate()[seqPos]);
+            }
+        }
+
+        // Remove the firing from the list of active actor firings
+        s->actClk[a->getId()].pop_front();
+
+    }
+
+
+    /**
+     * clockStep ()
+     * The function progresses time till the first end of firing transition
+     * becomes enabled. The time step is returned. In case of deadlock, the
+     * time step is equal to UINT_MAX.
+     */
+    CSDFtime CSDFstateSpaceThroughputAnalysis::TransitionSystem::clockStep()
+    {
+        CSDFtime step = UINT_MAX;
+
+        // Find maximal time progress
+        for (uint a = 0; a < g->nrActors(); a++)
+        {
+            if (!currentState.actClk[a].empty())
+            {
+                CSDFtime actClk = currentState.actClk[a].front();
+
+                if (step > actClk)
+                    step = actClk;
+            }
+        }
+
+        // Still actors ready to end their firing?
+        if (step == 0)
+            return 0;
+
+        // Check for progress (i.e. no deadlock)
+        if (step == UINT_MAX)
+            return UINT_MAX;
+
+        // Lower remaining execution time actors
+        for (uint a = 0; a < g->nrActors(); a++)
+        {
+            for (list<CSDFtime>::iterator iter = currentState.actClk[a].begin();
+                 iter != currentState.actClk[a].end(); iter++)
+            {
+                CSDFtime &actFiringTime = *iter;
+
+                // Lower remaining execution time of the actor firing
+                actFiringTime -= step;
+            }
+        }
+
+        // Advance the global clock
+        currentState.glbClk += (unsigned long) step;
+
+#ifdef _PRINT_STATESPACE
+        cout << "clk:   " << step << endl;
+#endif
+
+        return step;
+    }
+
+    /**
+     * execCSDFgraph()
+     * Execute the CSDF graph till a deadlock is found or a recurrent state.
+     * The throughput is returned.
+     */
+    TDtime CSDFstateSpaceThroughputAnalysis::TransitionSystem::execCSDFgraph()
+    {
+        StatesIter recurrentState;
+        CSDFtime clkStep;
+        int repCnt = 0;
+
+        // Clear the list of stored states
+        clearStoredStates();
+
+        // Create initial state
+        currentState.init(g->nrActors(), g->nrChannels());
+        currentState.clear();
+        previousState.init(g->nrActors(), g->nrChannels());
+        previousState.clear();
+
+        // Initial tokens and space
+        currentState.setInitialTokens(*g);
+
+#ifdef _PRINT_STATESPACE
+        cout << "### start statespace exploration" << endl;
+#endif
+
+        // Fire the actors
+        while (true)
+        {
+            // Store partial state to check for progress
+            for (uint i = 0; i < g->nrChannels(); i++)
+            {
+                previousState.ch[i] = currentState.ch[i];
+            }
+
+            // Finish actor firings
+	    #ifdef DEPS_OUT
+	    cout << "\t\t\tFinish actor firings" << endl;
+	    #endif
+            for (CSDFactorsIter iter = g->actorsBegin();
+                 iter != g->actorsEnd(); iter++)
+            {
+                CSDFactor *a = *iter;
+
+                while (actorReadyToEnd(a))
+                {
+                    if (outputActor == a->getId())
+                    {
+                        repCnt++;
+                        if (repCnt == outputActorRepCnt)
+                        {
+#ifdef _PRINT_STATESPACE
+                            currentState.print(cout);
+#endif
+                            // Add state to hash of visited states
+                            if (!storeState(currentState, recurrentState))
+                            {
+#ifdef _PRINT_STATESPACE
+                                cout << "### end statespace exploration" << endl;
+#endif
+                                return computeThroughput(recurrentState);
+                            }
+			    #ifdef DEPS_OUT
+			    cout << "Reset currentState.glbClk and repCnt to 0" << endl;
+			    #endif
+                            currentState.glbClk = 0;
+                            repCnt = 0;
+                        }
+                    }
+
+                    // End the actor firing
+                    endActorFiring(a);
+                }
+            }
+
+            // Start actor firings
+            for (CSDFactorsIter iter = g->actorsBegin();
+                 iter != g->actorsEnd(); iter++)
+            {
+                TimedCSDFactor *a = (TimedCSDFactor *)(*iter);
+
+                // Ready to fire actor a?
+                while (actorReadyToFire(a))
+                {
+                    // Fire actor a
+                    startActorFiring(a);
+                }
+            }
+
+            // Clock step
+            clkStep = clockStep();
+
+            // Deadlocked?
+            if (clkStep == UINT_MAX)
+            {
+#ifdef _PRINT_STATESPACE
+                cout << "### end statespace exploration" << endl;
+#endif
+                return 0;
+            }
+        }
+	#ifdef DEPS_OUT
+	cout << "\tAbstract dependency graph initialised" << endl;
+	#endif
+
+        return 0;
+    }
+
+    /**
+     * analyze ()
+     * Compute the throughput of an CSDF graph for unconstrained buffer sizes and
+     * using auto-concurrency using a state-space traversal.
+     */
+    TDtime CSDFstateSpaceThroughputAnalysis::analyze(TimedCSDFgraph *g)
+    {
+        CSDFstateSpaceThroughputAnalysis thrAnalysisAlgo;
+        CSDFgraph::RepetitionVector repVec;
+        TDtime thr;
+
+        // Compute repetition vector
+        repVec = g->getRepetitionVector();
+
+        // Check that the graph gr is a strongly connected graph
+        if (!isStronglyConnectedGraph(g))
+        {
+            // Split graph into its strongly connected components
+            // and find minimal throughput of all components
+            CSDFgraphComponents comp = stronglyConnectedComponents(g);
+            thr = TDTIME_MAX;
+
+            for (CSDFgraphComponentsIter iter = comp.begin();
+                 iter != comp.end(); iter++)
+            {
+                CSDFgraph::RepetitionVector repVecGC;
+                CSDFgraphComponent co = *iter;
+                TimedCSDFgraph *gc;
+                TDtime thrGc;
+                CId idFirstActor;
+                CId id;
+
+                // Construct graph from component
+                gc = (TimedCSDFgraph *) componentToCSDFgraph(co);
+
+                // Id of first actor in component
+                idFirstActor = (*gc->actorsBegin())->getId();
+
+                // Relabel actors
+                id = 0;
+                for (CSDFactorsIter iter = gc->actorsBegin();
+                     iter != gc->actorsEnd(); iter++)
+                {
+                    CSDFactor *u = *iter;
+
+                    u->setId(id);
+                    id++;
+                }
+
+                // Relabel channels
+                id = 0;
+                for (CSDFchannelsIter iter = gc->channelsBegin();
+                     iter != gc->channelsEnd(); iter++)
+                {
+                    CSDFchannel *c = *iter;
+
+                    c->setId(id);
+                    id++;
+                }
+
+                // Graph contains at least one channel
+                if (gc->nrChannels() > 0)
+                {
+                    // Compute throughput component
+                    thrGc = thrAnalysisAlgo.analyze(gc);
+
+                    // Compute repetition vector of component
+                    repVecGC = gc->getRepetitionVector();
+
+                    // Scale throughput wrt repetition vector component vs graph
+                    thrGc = (thrGc * repVecGC[0]) / (TDtime)(repVec[idFirstActor]);
+
+                    if (thrGc < thr)
+                        thr = thrGc;
+                }
+
+                // Cleanup
+                delete gc;
+            }
+
+            return thr;
+        }
+
+        // Create a transition system
+        TransitionSystem transitionSystem(g);
+
+        // Find the maximal throughput
+        thr = transitionSystem.execCSDFgraph();
+
+        return thr;
+    }
+}//namespace CSDF
diff -ruN sdf3_140724/sdf3/csdf/analysis/throughput/selftimed_throughput.cc.rej sdf3_custom/sdf3/csdf/analysis/throughput/selftimed_throughput.cc.rej
--- sdf3_140724/sdf3/csdf/analysis/throughput/selftimed_throughput.cc.rej	1970-01-01 07:30:00.000000000 +0730
+++ sdf3_custom/sdf3/csdf/analysis/throughput/selftimed_throughput.cc.rej	2022-04-13 21:25:58.259736324 +0800
@@ -0,0 +1,1380 @@
+*** buffer.cc	2014-07-24 12:16:04.000000000 +0800
+--- buffer.cc	2021-01-21 15:26:47.935610418 +0800
+***************
+*** 37,44 ****
+  
+  #include "buffer.h"
+  #include "../throughput/throughput.h"
+  namespace CSDF
+  {
+  
+      /******************************************************************************
+       * Bounds on the search space
+--- 37,62 ----
+  
+  #include "buffer.h"
+  #include "../throughput/throughput.h"
++ // libraries for data logging
++ #include <chrono>
++ // define variables to toggle verbose/extremely verbose/logging
++ // #define VERBOSE_OUT // print out explored storage distributions and results
++ // #define DEPS_OUT // extremely verbose output --- useful for understanding implementation of symbolic execution and storage deps
++ #define LOG_OUT // log data of DSE in CSVs
++ 
+  namespace CSDF
+  {
++   #ifdef VERBOSE_OUT
++   long int computation_counter = 0;
++   #endif
++   // variables for data logging
++   #ifdef LOG_OUT
++   string dirName = std::getenv("SDF3LOGDIR");
++   string logDirName = "dse_logs/";
++   string ppDirName = "pp_logs/";
++   ofstream dseLog; // save search path data in DSE log
++   std::chrono::duration<double, milli> cumulativeTime;
++   #endif
+  
+      /******************************************************************************
+       * Bounds on the search space
+***************
+*** 62,67 ****
+       */
+      void CSDFstateSpaceBufferAnalysis::initMinimalChannelSzStep(TimedCSDFgraph *g)
+      {
+          minSzStep = new TBufSize [g->nrChannels()];
+  
+          for (CSDFchannelsIter iter = g->channelsBegin(); iter != g->channelsEnd();
+--- 80,88 ----
+       */
+      void CSDFstateSpaceBufferAnalysis::initMinimalChannelSzStep(TimedCSDFgraph *g)
+      {
++       #ifdef VERBOSE_OUT
++       cout << "Calculating minimal channel step sizes..." << endl;
++       #endif
+          minSzStep = new TBufSize [g->nrChannels()];
+  
+          for (CSDFchannelsIter iter = g->channelsBegin(); iter != g->channelsEnd();
+***************
+*** 84,89 ****
+                  minStepSz = gcd(minStepSz, dstPort->getRate()[i]);
+  
+              minSzStep[ch->getId()] = minStepSz;
+          }
+      }
+  
+--- 105,114 ----
+                  minStepSz = gcd(minStepSz, dstPort->getRate()[i]);
+  
+              minSzStep[ch->getId()] = minStepSz;
++ 	    #ifdef VERBOSE_OUT
++ 	    cout << "Min. step size for channel " << ch->getName() << ": "
++ 		 << minStepSz << endl;
++ 	    #endif
+          }
+      }
+  
+***************
+*** 93,98 ****
+       */
+      void CSDFstateSpaceBufferAnalysis::initMinimalChannelSz(TimedCSDFgraph *g)
+      {
+          minSz =  new TBufSize [g->nrChannels()];
+  
+          for (CSDFchannelsIter iter = g->channelsBegin(); iter != g->channelsEnd();
+--- 118,126 ----
+       */
+      void CSDFstateSpaceBufferAnalysis::initMinimalChannelSz(TimedCSDFgraph *g)
+      {
++       #ifdef VERBOSE_OUT
++       cout << "Calculating minimal channel sizes (for positive throughput)..." << endl;
++       #endif
+          minSz =  new TBufSize [g->nrChannels()];
+  
+          for (CSDFchannelsIter iter = g->channelsBegin(); iter != g->channelsEnd();
+***************
+*** 116,121 ****
+                  uint t = ch->getInitialTokens();
+                  uint lb;
+  
+                  // Lower-bound of a self-edge is rate at which data is produced and
+                  // consumed and the number of initial tokens present
+                  if (ch->getSrcActor()->getId() == ch->getDstActor()->getId())
+--- 144,152 ----
+                  uint t = ch->getInitialTokens();
+                  uint lb;
+  
++ 		#ifdef VERBOSE_OUT
++ 		cout << "p, c, t: " << p << ", " << c << ", " << t << endl;
++ 		#endif
+                  // Lower-bound of a self-edge is rate at which data is produced and
+                  // consumed and the number of initial tokens present
+                  if (ch->getSrcActor()->getId() == ch->getDstActor()->getId())
+***************
+*** 151,156 ****
+  
+          for (uint c = 0; c < g->nrChannels(); c++)
+              lbDistributionSz += minSz[c];
+      }
+  
+      /**
+--- 186,194 ----
+  
+          for (uint c = 0; c < g->nrChannels(); c++)
+              lbDistributionSz += minSz[c];
++ 	#ifdef VERBOSE_OUT
++ 	cout << "Lower bound distribution size: " << lbDistributionSz << endl;
++ 	#endif
+      }
+  
+      /**
+***************
+*** 162,167 ****
+          CSDFstateSpaceThroughputAnalysis thrAnalysisAlgo;
+  
+          maxThroughput = thrAnalysisAlgo.analyze(g);
+      }
+  
+      /******************************************************************************
+--- 200,208 ----
+          CSDFstateSpaceThroughputAnalysis thrAnalysisAlgo;
+  
+          maxThroughput = thrAnalysisAlgo.analyze(g);
++ 	#ifdef VERBOSE_OUT
++ 	cout << "Max throughput: " << maxThroughput << endl;
++ 	#endif
+      }
+  
+      /******************************************************************************
+***************
+*** 391,396 ****
+                  if (color[b] == 1)
+                  {
+                      // Found a cycle in the graph containing node b
+                      c = a;
+                      d = b;
+                      do
+--- 437,446 ----
+                  if (color[b] == 1)
+                  {
+                      // Found a cycle in the graph containing node b
++ 		  #ifdef DEPS_OUT
++ 		  cout << "\t\t\t\t Found cycle in abstract dep graph containing node from actor "
++ 		       << g->getActor(a)->getName() << " and actor " << g->getActor(b)->getName() << endl;
++ 		  #endif
+                      c = a;
+                      d = b;
+                      do
+***************
+*** 405,411 ****
+                              CId dstId = ch->getDstActor()->getId();
+  
+                              if (dstId == d && srcId == c)
+                                  dep[ch->getId()] = true;
+                          }
+  
+                          // Next
+--- 455,466 ----
+                              CId dstId = ch->getDstActor()->getId();
+  
+                              if (dstId == d && srcId == c)
++ 			      {
++ 				#ifdef DEPS_OUT
++ 				cout << "\t\t\t\t  Storage dependency found in channel " << ch->getName() << endl;
++ 				#endif
+                                  dep[ch->getId()] = true;
++ 			      }
+                          }
+  
+                          // Next
+***************
+*** 541,560 ****
+              // Actor is destination of the channel?
+              if (p->getType() == CSDFport::In)
+              {
+                  CONSUME(c->getId(), p->getRate()[ACT_SEQ_POS(a->getId())]);
+              }
+              else
+              {
+!                 CONSUME_SP(c->getId(), p->getRate()[ACT_SEQ_POS(a->getId())]);
+              }
+          }
+  
+          // Add actor firing to the list of active firings of this actor
+          currentState.actClk[a->getId()].push_back(
+              a->getExecutionTime()[ACT_SEQ_POS(a->getId())]);
+  
+          // Advance the sequence position of the actor
+          ACT_SEQ_POS(a->getId()) = (ACT_SEQ_POS(a->getId()) + 1) % a->sequenceLength();
+      }
+  
+      /**
+--- 599,635 ----
+              // Actor is destination of the channel?
+              if (p->getType() == CSDFport::In)
+              {
++ 	      #ifdef DEPS_OUT
++ 	      cout << "\tConsume " << p->getRate()[ACT_SEQ_POS(a->getId())]
++ 		   << " tokens from channel " << c->getName() << endl;
++ 	      #endif
+                  CONSUME(c->getId(), p->getRate()[ACT_SEQ_POS(a->getId())]);
+              }
+              else
+              {
+! 	      #ifdef DEPS_OUT
+! 	      cout << "\tSpace in channel " << c->getName() << " reduced by "
+! 		   << p->getRate()[ACT_SEQ_POS(a->getId())] << endl;
+! 	      #endif
+! 	      CONSUME_SP(c->getId(), p->getRate()[ACT_SEQ_POS(a->getId())]);
+              }
+          }
+  
+          // Add actor firing to the list of active firings of this actor
+          currentState.actClk[a->getId()].push_back(
+              a->getExecutionTime()[ACT_SEQ_POS(a->getId())]);
++ 	#ifdef DEPS_OUT
++ 	cout << "\t\tAdd actor firing to list of active firings of actor:" << endl;
++ 	cout << "\t\tExecution time of " << a->getExecutionTime()[ACT_SEQ_POS(a->getId())]
++ 	     << " added" << endl;
++ 	#endif
+  
+          // Advance the sequence position of the actor
+          ACT_SEQ_POS(a->getId()) = (ACT_SEQ_POS(a->getId()) + 1) % a->sequenceLength();
++ 	#ifdef DEPS_OUT
++ 	cout << "\t\tActor is now in phase " << ACT_SEQ_POS(a->getId()) << endl;
++ 	currentState.print(cout);
++ 	#endif
+      }
+  
+      /**
+***************
+*** 583,588 ****
+      void CSDFstateSpaceBufferAnalysis::TransitionSystem::endActorFiring(
+          CSDFactor *a)
+      {
+          for (CSDFportsIter iter = a->portsBegin(); iter != a->portsEnd(); iter++)
+          {
+              CSDFport *p = *iter;
+--- 658,666 ----
+      void CSDFstateSpaceBufferAnalysis::TransitionSystem::endActorFiring(
+          CSDFactor *a)
+      {
++       #ifdef DEPS_OUT
++       cout << "End firing of actor " << a->getName() << endl;
++       #endif
+          for (CSDFportsIter iter = a->portsBegin(); iter != a->portsEnd(); iter++)
+          {
+              CSDFport *p = *iter;
+***************
+*** 596,611 ****
+              // Actor is source of the channel?
+              if (p->getType() == CSDFport::Out)
+              {
+!                 PRODUCE(c->getId(), p->getRate()[seqPos]);
+              }
+              else
+              {
+                  PRODUCE_SP(c->getId(), p->getRate()[seqPos]);
+              }
+          }
+  
+          // Remove the firing from the list of active actor firings
+          currentState.actClk[a->getId()].pop_front();
+      }
+  
+      /**
+--- 674,701 ----
+              // Actor is source of the channel?
+              if (p->getType() == CSDFport::Out)
+              {
+! 	      #ifdef DEPS_OUT
+! 	      cout << "\tProduce " << p->getRate()[seqPos]
+! 		   << " tokens into channel " << c->getName() << endl;
+! 	      #endif
+! 	      PRODUCE(c->getId(), p->getRate()[seqPos]);
+              }
+              else
+              {
++ 	      #ifdef DEPS_OUT
++ 	      cout << "\tSpace in channel " << c->getName() << " increased by "
++ 		   << p->getRate()[seqPos] << endl;
++ 	      #endif
+                  PRODUCE_SP(c->getId(), p->getRate()[seqPos]);
+              }
+          }
+  
+          // Remove the firing from the list of active actor firings
+          currentState.actClk[a->getId()].pop_front();
++ 	#ifdef DEPS_OUT
++ 	cout << "\t\tRemove actor firing to list of active firings of actor" << endl;
++         currentState.print(cout);
++ 	#endif
+      }
+  
+      /**
+***************
+*** 681,686 ****
+                  if (!CH_TOKENS_PREV(c->getId(),
+                                      p->getRate()[ACT_SEQ_POS(a->getId())]))
+                  {
+                      abstractDepGraph[dstActor->getId()][srcActor->getId()] = true;
+                  }
+              }
+--- 771,787 ----
+                  if (!CH_TOKENS_PREV(c->getId(),
+                                      p->getRate()[ACT_SEQ_POS(a->getId())]))
+                  {
++ 		  #ifdef DEPS_OUT
++ 		  cout << "\t\t\t\tFound causal dependency in channel " << c->getName()
++ 		       << ": not enough tokens in previous state (needed at least "
++ 		       << p->getRate()[ACT_SEQ_POS(a->getId())] << " tokens)" << endl;
++ 		  cout << "Previous state:" << endl;
++ 		  previousState.print(cout);
++ 		  cout << endl;
++ 		  cout << "Current state:" << endl;
++ 		  currentState.print(cout);
++ 		  cout << endl;
++ 		  #endif
+                      abstractDepGraph[dstActor->getId()][srcActor->getId()] = true;
+                  }
+              }
+***************
+*** 690,695 ****
+                  if (!CH_SPACE_PREV(c->getId(),
+                                     p->getRate()[ACT_SEQ_POS(a->getId())]))
+                  {
+                      abstractDepGraph[srcActor->getId()][dstActor->getId()] = true;
+                  }
+              }
+--- 791,807 ----
+                  if (!CH_SPACE_PREV(c->getId(),
+                                     p->getRate()[ACT_SEQ_POS(a->getId())]))
+                  {
++ 		  #ifdef DEPS_OUT
++ 		  cout << "\t\t\t\tFound causal dependency in channel " << c->getName()
++ 		       << ": not enough space in previous state (needed at least "
++ 		       << p->getRate()[ACT_SEQ_POS(a->getId())] << " space)" << endl;
++ 		  cout << "Previous state:" << endl;
++ 		  previousState.print(cout);
++ 		  cout << endl;
++ 		  cout << "Current state:" << endl;
++ 		  currentState.print(cout);
++ 		  cout << endl;
++ 		  #endif
+                      abstractDepGraph[srcActor->getId()][dstActor->getId()] = true;
+                  }
+              }
+***************
+*** 720,745 ****
+              for (uint j = 0; j < g->nrActors(); j++)
+                  abstractDepGraph[i][j] = false;
+          }
+  
+          // Start new iteration of the periodic phase
+          currentState.glbClk = 0;
+  
+          // Still need to complete the last firing of the output actor
+          // before period really ends
+!         repCnt = -1;
+  
+          // Complete the remaining actor firings
+          for (CSDFactorsIter iter = g->actorsBegin(); iter != g->actorsEnd(); iter++)
+          {
+              CSDFactor *a = *iter;
+  
+              while (actorReadyToEnd(a))
+              {
+                  if (a->getId() == outputActor->getId())
+                  {
+                      repCnt++;
+                      if (repCnt == outputActorRepCnt)
+                      {
+                          currentState.glbClk = 0;
+                          repCnt = 0;
+                      }
+--- 832,877 ----
+              for (uint j = 0; j < g->nrActors(); j++)
+                  abstractDepGraph[i][j] = false;
+          }
++ 	#ifdef DEPS_OUT
++ 	cout << "\t\t\tAbstract dependency graph initialised" << endl;
++ 	#endif
+  
+          // Start new iteration of the periodic phase
+          currentState.glbClk = 0;
++ 	#ifdef DEPS_OUT
++ 	cout << "\t\t\tReset global clock for new iteration of periodic phase:" << endl;
++ 	currentState.print(cout);
++ 	#endif
+  
+          // Still need to complete the last firing of the output actor
+          // before period really ends
+!         repCnt = -1; // so that output actor is executed one more time
+  
+          // Complete the remaining actor firings
++ 	#ifdef DEPS_OUT
++ 	cout << "\t\t\tCompleting remaining actor firings" << endl;
++ 	#endif
+          for (CSDFactorsIter iter = g->actorsBegin(); iter != g->actorsEnd(); iter++)
+          {
+              CSDFactor *a = *iter;
+  
+              while (actorReadyToEnd(a))
+              {
++ 	      #ifdef DEPS_OUT
++ 	      cout << "\n\t\t\tActor " << a->getName() << " ready to end...." << endl;
++ 	      #endif
+                  if (a->getId() == outputActor->getId())
+                  {
+                      repCnt++;
++ 		    #ifdef DEPS_OUT
++ 		    cout << "\t\t\tActor is output actor (has lowest rep vector value): incrementing repCnt to: "
++ 			 << repCnt << endl;
++ 		    #endif
+                      if (repCnt == outputActorRepCnt)
+                      {
++ 		      #ifdef DEPS_OUT
++ 		      cout << "\t\t\trepCnt equal to outputActorRepCnt: reset currentState.glbClk and repCnt to 0" << endl;
++ 		      #endif
+                          currentState.glbClk = 0;
+                          repCnt = 0;
+                      }
+***************
+*** 761,766 ****
+                  // Ready to fire actor a?
+                  while (actorReadyToFire(a))
+                  {
+                      // Track causal dependencies on firing of actor a
+                      findCausalDependencies(a, abstractDepGraph);
+  
+--- 893,902 ----
+                  // Ready to fire actor a?
+                  while (actorReadyToFire(a))
+                  {
++ 		  #ifdef DEPS_OUT
++ 		  cout << "\n\t\t\tActor " << a->getName() << " ready to fire" << endl;
++ 		  cout << "\t\t\tFind causal dependencies for this actor" << endl;
++ 		  #endif
+                      // Track causal dependencies on firing of actor a
+                      findCausalDependencies(a, abstractDepGraph);
+  
+***************
+*** 772,777 ****
+              // Clock step
+              clockStep();
+  
+              // Store partial state to check for progress
+              for (uint i = 0; i < g->nrChannels(); i++)
+              {
+--- 908,916 ----
+              // Clock step
+              clockStep();
+  
++ 	    #ifdef DEPS_OUT
++ 	    cout << "\t\t\tStoring partial state by setting current state ch and sp to prev state" << endl;
++ 	    #endif
+              // Store partial state to check for progress
+              for (uint i = 0; i < g->nrChannels(); i++)
+              {
+***************
+*** 790,803 ****
+  
+                  while (actorReadyToEnd(a))
+                  {
+                      if (outputActor->getId() == a->getId())
+                      {
+                          repCnt++;
+                          if (repCnt == outputActorRepCnt)
+                          {
+                              // Found periodic state
+                              if (currentState == periodicState)
+                              {
+                                  // Cycles in the dependency graph indicate storage
+                                  // dependencies
+                                  findStorageDependencies(abstractDepGraph, dep);
+--- 932,959 ----
+  
+                  while (actorReadyToEnd(a))
+                  {
++ 		  #ifdef DEPS_OUT
++ 		  cout << "\n\t\t\tActor " << a->getName() << " ready to end...." << endl;
++ 		  #endif
+                      if (outputActor->getId() == a->getId())
+                      {
+                          repCnt++;
++ 			#ifdef DEPS_OUT
++ 			cout << "\t\t\tActor is output actor (has lowest rep vector value): incrementing repCnt to: "
++ 			     << repCnt << endl;
++ 			#endif
+                          if (repCnt == outputActorRepCnt)
+                          {
++ 			  #ifdef DEPS_OUT
++ 			  cout << "\t\t\trepCnt equal to outputActorRepCnt:" << endl;
++ 			  #endif
+                              // Found periodic state
+                              if (currentState == periodicState)
+                              {
++ 			      #ifdef DEPS_OUT
++ 			      cout << "\t\t\tCurrent state is the periodic state" << endl;
++ 			      cout << "\t\t\t\tLook for storage dependencies (cycles in abstract dependency graph)" << endl;
++ 			      #endif
+                                  // Cycles in the dependency graph indicate storage
+                                  // dependencies
+                                  findStorageDependencies(abstractDepGraph, dep);
+***************
+*** 858,863 ****
+              if (!CH_TOKENS(c->getId(),
+                             c->getDstPort()->getRate()[ACT_SEQ_POS(dstActor->getId())]))
+              {
+                  abstractDepGraph[dstActor->getId()][srcActor->getId()] = true;
+              }
+  
+--- 1020,1031 ----
+              if (!CH_TOKENS(c->getId(),
+                             c->getDstPort()->getRate()[ACT_SEQ_POS(dstActor->getId())]))
+              {
++ 	      #ifdef DEPS_OUT
++ 	      cout << "\t\tFound causal dependency in channel " << c->getName()
++ 		   << ": not enough tokens to fire destination actor " << dstActor->getName()
++ 		   << " (needed at least " << c->getDstPort()->getRate()[ACT_SEQ_POS(dstActor->getId())]
++ 		   << " tokens)" << endl;
++ 	      #endif
+                  abstractDepGraph[dstActor->getId()][srcActor->getId()] = true;
+              }
+  
+***************
+*** 865,870 ****
+              if (!CH_SPACE(c->getId(),
+                            c->getSrcPort()->getRate()[ACT_SEQ_POS(srcActor->getId())]))
+              {
+                  abstractDepGraph[srcActor->getId()][dstActor->getId()] = true;
+              }
+          }
+--- 1033,1044 ----
+              if (!CH_SPACE(c->getId(),
+                            c->getSrcPort()->getRate()[ACT_SEQ_POS(srcActor->getId())]))
+              {
++ 	      #ifdef DEPS_OUT
++ 	      cout << "\t\tFound causal dependency in channel " << c->getName()
++ 		   << ": not enough space to fire source actor " << srcActor->getName()
++ 		   << " (needed at least " << c->getSrcPort()->getRate()[ACT_SEQ_POS(dstActor->getId())]
++ 		   << " space)" << endl;
++ 	      #endif
+                  abstractDepGraph[srcActor->getId()][dstActor->getId()] = true;
+              }
+          }
+***************
+*** 894,899 ****
+          clearStoredStates();
+  
+          // Create initial state
+          currentState.init(g->nrActors(), g->nrChannels());
+          currentState.clear();
+          previousState.init(g->nrActors(), g->nrChannels());
+--- 1068,1077 ----
+          clearStoredStates();
+  
+          // Create initial state
++ 	#ifdef DEPS_OUT
++ 	cout << "Initialising previous and current states with " << to_string(g->nrActors())
++ 	     << " actors and " << to_string(g->nrChannels()) << " channels" << endl;
++ 	#endif
+          currentState.init(g->nrActors(), g->nrChannels());
+          currentState.clear();
+          previousState.init(g->nrActors(), g->nrChannels());
+***************
+*** 912,922 ****
+                  return 0;
+              }
+  
+              CH(c->getId()) = c->getInitialTokens();
+              SP(c->getId()) = sp[c->getId()] - c->getInitialTokens();
+          }
+  
+          // Fire the actors
+          while (true)
+          {
+              // Store partial state to check for progress
+--- 1090,1111 ----
+                  return 0;
+              }
+  
++ 	    #ifdef DEPS_OUT
++ 	    cout << "Setting initial tokens and space for channel: " << c->getName() << " ("
++ 		 << c->getInitialTokens() << ", " << sp[c->getId()] - c->getInitialTokens()
++ 		 << ")" << endl;
++ 	    #endif
+              CH(c->getId()) = c->getInitialTokens();
+              SP(c->getId()) = sp[c->getId()] - c->getInitialTokens();
++ 	    #ifdef DEPS_OUT
++ 	    c->print(cout);
++ 	    #endif
+          }
+  
+          // Fire the actors
++ 	#ifdef DEPS_OUT
++ 	cout << "\nBegin actor firings" << endl;
++ 	#endif
+          while (true)
+          {
+              // Store partial state to check for progress
+***************
+*** 934,948 ****
+  
+                  while (actorReadyToEnd(a))
+                  {
+                      if (outputActor->getId() == a->getId())
+                      {
+                          repCnt++;
+                          if (repCnt == outputActorRepCnt)
+                          {
+                              // Add state to hash of visited states
+                              if (!storeState(currentState, recurrentState))
+                              {
+!                                 // Find storage dependencies in periodic phase
+                                  analyzePeriodicPhase(sp, dep);
+  
+                                  return computeThroughput(recurrentState);
+--- 1123,1150 ----
+  
+                  while (actorReadyToEnd(a))
+                  {
++ 		  #ifdef DEPS_OUT
++ 		  cout << "\nActor " << a->getName() << " ready to end...." << endl;
++ 		  #endif
+                      if (outputActor->getId() == a->getId())
+                      {
+                          repCnt++;
++ 			#ifdef DEPS_OUT
++ 			cout << "\tActor is output actor (has lowest rep vector value): incrementing repCnt to: "
++ 			     << repCnt << endl;
++ 			#endif
+                          if (repCnt == outputActorRepCnt)
+                          {
++ 			  #ifdef DEPS_OUT
++ 			  cout << "\t\trepCnt equal to outputActorRepCnt" << endl;
++ 			  #endif
+                              // Add state to hash of visited states
+                              if (!storeState(currentState, recurrentState))
+                              {
+! 			      // Find storage dependencies in periodic phase
+! 			      #ifdef DEPS_OUT
+! 			      cout << "\t\tCurrent state has been visited before: analyse periodic phase" << endl;
+! 			      #endif
+                                  analyzePeriodicPhase(sp, dep);
+  
+                                  return computeThroughput(recurrentState);
+***************
+*** 966,971 ****
+                  // Ready to fire actor a?
+                  while (actorReadyToFire(a))
+                  {
+                      // Fire actor a
+                      startActorFiring(a);
+                  }
+--- 1168,1176 ----
+                  // Ready to fire actor a?
+                  while (actorReadyToFire(a))
+                  {
++ 		  #ifdef DEPS_OUT
++ 		  cout << "\nActor " << a->getName() << " ready to fire" << endl;
++ 		  #endif
+                      // Fire actor a
+                      startActorFiring(a);
+                  }
+***************
+*** 973,982 ****
+  
+              // Clock step
+              clkStep = clockStep();
+  
+              // Deadlocked?
+              if (clkStep == UINT_MAX)
+              {
+                  // Find cause of deadlock
+                  analyzeDeadlock(sp, dep);
+                  return 0;
+--- 1178,1193 ----
+  
+              // Clock step
+              clkStep = clockStep();
++ 	    #ifdef DEPS_OUT
++ 	    cout << "clkStep set to " << clkStep << endl;
++ 	    #endif
+  
+              // Deadlocked?
+              if (clkStep == UINT_MAX)
+              {
++ 	      #ifdef DEPS_OUT
++ 	      cout << "clkStep too high, deadlock found: analyse deadlock" << endl;
++ 	      #endif
+                  // Find cause of deadlock
+                  analyzeDeadlock(sp, dep);
+                  return 0;
+***************
+*** 1028,1041 ****
+          // Initialize blocking channels
+          for (uint c = 0; c < g->nrChannels(); c++)
+              d->dep[c] = false;
+! 
+          // Execute the CSDF graph to find its output interval
+          d->thr = transitionSystem->execCSDFgraph(d->sp, d->dep);
+! 
+          //cerr << d->sz << " " << d->thr << endl;
+          //for (uint c = 0; c < g->nrChannels(); c++)
+          //    cerr << d->sp[c] << " " << d->dep[c] << endl;
+          //cerr << endl;
+      }
+  
+      /**
+--- 1239,1291 ----
+          // Initialize blocking channels
+          for (uint c = 0; c < g->nrChannels(); c++)
+              d->dep[c] = false;
+! 	
+          // Execute the CSDF graph to find its output interval
+          d->thr = transitionSystem->execCSDFgraph(d->sp, d->dep);
+! 	
+          //cerr << d->sz << " " << d->thr << endl;
+          //for (uint c = 0; c < g->nrChannels(); c++)
+          //    cerr << d->sp[c] << " " << d->dep[c] << endl;
+          //cerr << endl;
++ 
++ 	#ifdef VERBOSE_OUT
++ 	cout << "\tCurrent StorageDistribution info:" << endl;
++ 	cout << "\tNumber of edges: " << g->nrChannels() << endl;
++ 	cout << "\tChannel quantities:\n\t";
++ 	for (CSDFchannelsIter iter = g->channelsBegin();
++ 	     iter != g->channelsEnd(); iter++) {
++ 	  CSDFchannel *c = *iter;
++ 	  if (c->getSrcActor()->getId() != c->getDstActor()->getId()) { // ignore feedback edges
++ 	    cout << d->sp[c->getId()] << " ";
++ 	  }
++ 	}
++ 	cout << endl;
++ 	cout << "\tDistribution size: " << d->sz << endl;
++ 	cout << "\tThroughput: " << d->thr << endl;
++ 	cout << endl;
++ 	#endif
++ 
++ 	#ifdef LOG_OUT
++ 	// log dse data
++ 	string output("\"");
++ 	string delim("");
++ 	uint noFeedbackSize = 0;	
++ 	for (CSDFchannelsIter iter = g->channelsBegin();
++ 	     iter != g->channelsEnd(); iter++) {
++ 	  CSDFchannel *c = *iter;
++ 	  if (c->getSrcActor()->getId() != c->getDstActor()->getId()) { // ignore feedback edges
++ 	    output += delim;
++ 	    output += to_string(d->sp[c->getId()]);
++ 	    delim = ",";
++ 	    noFeedbackSize += d->sp[c->getId()];
++ 	  }
++ 	}
++ 	output += "\"";
++ 	
++ 	dseLog << noFeedbackSize << "," // distribution size
++ 	       << d->thr << "," // throughput
++ 	       << output << ","; // channel quantities
++ 	#endif
+      }
+  
+      /**
+***************
+*** 1053,1058 ****
+          // throughput with previous (smaller) distribution size
+          if (ds->prev != NULL && ds->prev->thr == ds->thr)
+          {
+              // No minimal storage distributions exist in this list
+              // Iterate over the list of storage distributions
+              d = ds->distributions;
+--- 1303,1312 ----
+          // throughput with previous (smaller) distribution size
+          if (ds->prev != NULL && ds->prev->thr == ds->thr)
+          {
++ 	  #ifdef VERBOSE_OUT
++ 	  cout << "\t\tNew storage distribution set of dist size " << ds->sz
++ 	       << " found to be non-minimal: removing from set" << endl;
++ 	  #endif
+              // No minimal storage distributions exist in this list
+              // Iterate over the list of storage distributions
+              d = ds->distributions;
+***************
+*** 1093,1098 ****
+                      t = d->next;
+  
+                      // Cleanup d
+                      deleteStorageDistribution(d);
+  
+                      // Next
+--- 1347,1356 ----
+                      t = d->next;
+  
+                      // Cleanup d
++ 		    #ifdef VERBOSE_OUT
++ 		    cout << "\t\tStorage distribution of size " << d->sz
++ 			 << " found to be non-minimal: removing from set" << endl;
++ 		    #endif
+                      deleteStorageDistribution(d);
+  
+                      // Next
+***************
+*** 1123,1131 ****
+          StorageDistribution *di;
+          bool equalDistr;
+  
+          // First distribution ever added?
+          if (minStorageDistributions == NULL)
+          {
+              // Create new set of storage distributions
+              dsNew = new StorageDistributionSet;
+              dsNew->sz = d->sz;
+--- 1381,1396 ----
+          StorageDistribution *di;
+          bool equalDistr;
+  
++ 	#ifdef VERBOSE_OUT
++ 	cout << "\t\tAttempting to add storage distribution of dist sz: " << d->sz
++ 	     << " to set" << endl;
++ 	#endif
+          // First distribution ever added?
+          if (minStorageDistributions == NULL)
+          {
++ 	  #ifdef VERBOSE_OUT
++ 	  cout << "\t\t\tFirst of this distribution size: adding new distribution" << endl;
++ 	  #endif
+              // Create new set of storage distributions
+              dsNew = new StorageDistributionSet;
+              dsNew->sz = d->sz;
+***************
+*** 1168,1181 ****
+                  }
+  
+                  // Found equal distribution
+!                 if (equalDistr)
+!                     return false;
+  
+                  // Next
+                  di = di->next;
+              }
+  
+              // Distribution 'd' not yet in the set, so let's add it
+              ds->distributions->prev = d;
+              d->next = ds->distributions;
+              ds->distributions = d;
+--- 1433,1453 ----
+                  }
+  
+                  // Found equal distribution
+!                 if (equalDistr) {
+! 		  #ifdef VERBOSE_OUT
+! 		  cout << "\t\t\tFound matching distribution: not adding new distribution" << endl;
+! 		  #endif
+! 		  return false;
+! 		}
+  
+                  // Next
+                  di = di->next;
+              }
+  
+              // Distribution 'd' not yet in the set, so let's add it
++ 	    #ifdef VERBOSE_OUT
++ 	    cout << "\t\t\tNew storage distribution added!" << endl;
++ 	    #endif
+              ds->distributions->prev = d;
+              d->next = ds->distributions;
+              ds->distributions = d;
+***************
+*** 1183,1189 ****
+          else if (ds->next == NULL)
+          {
+              // No set of distribution in the list with same or larger size?
+! 
+              // Create new set of storage distributions
+              dsNew = new StorageDistributionSet;
+              dsNew->sz = d->sz;
+--- 1455,1463 ----
+          else if (ds->next == NULL)
+          {
+              // No set of distribution in the list with same or larger size?
+! 	  #ifdef VERBOSE_OUT
+! 	  cout << "\t\t\tFirst of this distribution size: adding new distribution" << endl;
+! 	  #endif
+              // Create new set of storage distributions
+              dsNew = new StorageDistributionSet;
+              dsNew->sz = d->sz;
+***************
+*** 1203,1208 ****
+              // distribution 'd'.
+  
+              // Create new set of storage distributions
+              dsNew = new StorageDistributionSet;
+              dsNew->sz = d->sz;
+              dsNew->thr = 0;
+--- 1477,1485 ----
+              // distribution 'd'.
+  
+              // Create new set of storage distributions
++ 	  #ifdef VERBOSE_OUT
++ 	  cout << "\t\t\tFirst of this distribution size: adding new distribution" << endl;
++ 	  #endif
+              dsNew = new StorageDistributionSet;
+              dsNew->sz = d->sz;
+              dsNew->thr = 0;
+***************
+*** 1232,1244 ****
+      {
+          StorageDistribution *dNew;
+  
+          // Compute throughput and storage dependencies
+          execStorageDistribution(d);
+  
+          // Throughput of d larger then current maximum of the set
+          if (d->thr > ds->thr)
+              ds->thr = d->thr;
+  
+          // Create new storage distributions for every channel which
+          // has a storage dependency in d
+          for (uint c = 0; c < g->nrChannels(); c++)
+--- 1509,1538 ----
+      {
+          StorageDistribution *dNew;
+  
++ 	#ifdef LOG_OUT
++ 	auto startTime = std::chrono::steady_clock::now();
++ 	#endif
+          // Compute throughput and storage dependencies
+          execStorageDistribution(d);
++ 	#ifdef LOG_OUT
++ 	auto endTime = std::chrono::steady_clock::now();
++ 	std::chrono::duration<double, milli> execTime = endTime - startTime; // duration of individual execution
++ 	cumulativeTime += execTime;
++ 	#endif
++ 	#ifdef VERBOSE_OUT
++ 	computation_counter++;
++ 	#endif
+  
+          // Throughput of d larger then current maximum of the set
+          if (d->thr > ds->thr)
+              ds->thr = d->thr;
+  
++ 	#ifdef LOG_OUT
++ 	// log execution times (cont. from execStorageDistribution)
++ 	dseLog << execTime.count() << ","
++ 	       << cumulativeTime.count() << endl;
++ 	#endif
++ 
+          // Create new storage distributions for every channel which
+          // has a storage dependency in d
+          for (uint c = 0; c < g->nrChannels(); c++)
+***************
+*** 1246,1255 ****
+              // Channel c has storage dependency?
+              if (d->dep[c])
+              {
+                  // Do not enlarge the channel if its a self-edge
+                  if (g->getChannel(c)->getSrcActor()->getId()
+!                     == g->getChannel(c)->getDstActor()->getId())
+!                     continue;
+  
+                  // Create new storage distribution with channel c enlarged
+                  dNew = newStorageDistribution();
+--- 1540,1556 ----
+              // Channel c has storage dependency?
+              if (d->dep[c])
+              {
++ 	      #ifdef VERBOSE_OUT
++ 	      cout << "\tFound storage dependency in channel " << g->getChannel(c)->getName() << endl;
++ 	      #endif
+                  // Do not enlarge the channel if its a self-edge
+                  if (g->getChannel(c)->getSrcActor()->getId()
+!                     == g->getChannel(c)->getDstActor()->getId()) {
+! 		  #ifdef VERBOSE_OUT
+! 		  cout << "\t\tChannel " << g->getChannel(c)->getName() << " is a self-edge: ignoring" << endl;
+! 		  #endif
+! 		  continue;
+! 		}
+  
+                  // Create new storage distribution with channel c enlarged
+                  dNew = newStorageDistribution();
+***************
+*** 1258,1270 ****
+                  for (uint i = 0; i < g->nrChannels(); i++)
+                  {
+                      dNew->sp[i] = d->sp[i];
+!                     if (i == c)
+!                         dNew->sp[i] += minSzStep[c];
+                  }
+                  dNew->next = NULL;
+                  dNew->prev = NULL;
+  
+                  // Add storage distribution to set of distributions to be checked
+                  if (!addStorageDistributionToChecklist(dNew))
+                  {
+                      // Distribution already in check list
+--- 1559,1579 ----
+                  for (uint i = 0; i < g->nrChannels(); i++)
+                  {
+                      dNew->sp[i] = d->sp[i];
+!                     if (i == c) {
+! 		      dNew->sp[i] += minSzStep[c];
+! 		      #ifdef VERBOSE_OUT
+! 		      cout << "\t\tIncreasing channel size of " << g->getChannel(c)->getName()
+! 			   << " to " << dNew->sp[i] << endl;
+! 		      #endif
+! 		    }
+                  }
+                  dNew->next = NULL;
+                  dNew->prev = NULL;
+  
+                  // Add storage distribution to set of distributions to be checked
++ 		#ifdef VERBOSE_OUT
++ 		cout << "\tUpdating checklist with new storage distribution..." << endl;
++ 		#endif
+                  if (!addStorageDistributionToChecklist(dNew))
+                  {
+                      // Distribution already in check list
+***************
+*** 1288,1293 ****
+          d = ds->distributions;
+          while (d != NULL)
+          {
+              // Explore distribution d
+              exploreStorageDistribution(ds, d);
+  
+--- 1597,1605 ----
+          d = ds->distributions;
+          while (d != NULL)
+          {
++ 	  #ifdef VERBOSE_OUT
++ 	  cout << "\nExploring new storage distribution:" << endl;
++ 	  #endif
+              // Explore distribution d
+              exploreStorageDistribution(ds, d);
+  
+***************
+*** 1296,1301 ****
+          }
+  
+          // Remove all non-minimal storage distributions from the set
+          minimizeStorageDistributionsSet(ds);
+      }
+  
+--- 1608,1617 ----
+          }
+  
+          // Remove all non-minimal storage distributions from the set
++ 	#ifdef VERBOSE_OUT
++ 	cout << "\tTrying to minimise set with distribution size: "
++ 	     << ds->sz << endl;
++ 	#endif
+          minimizeStorageDistributionsSet(ds);
+      }
+  
+***************
+*** 1326,1331 ****
+          // Check sets of storage distributions till no distributions left to check,
+          // or throughput bound exceeded, or maximal throughput reached
+          ds = minStorageDistributions;
+          while (ds != NULL)
+          {
+              // Explore all distributions with size 'ds->sz'
+--- 1642,1658 ----
+          // Check sets of storage distributions till no distributions left to check,
+          // or throughput bound exceeded, or maximal throughput reached
+          ds = minStorageDistributions;
++ 
++ 	// Initialise log file
++ 	#ifdef LOG_OUT
++ 	dseLog.open(dirName + logDirName + g->getName() + "_dselog_sdf3.csv");
++ 	dseLog << "storage distribution size,throughput,channel quantities,computation duration,cumulative duration"
++ 	       << endl; // initialise headers
++ 	#endif
++ 
++ 	#ifdef VERBOSE_OUT
++ 	cout << "DSE BEGIN:" << endl;
++ 	#endif
+          while (ds != NULL)
+          {
+              // Explore all distributions with size 'ds->sz'
+***************
+*** 1411,1416 ****
+              for (uint c = 0; c < g->nrChannels(); c++)
+                  minStorageDistributions->distributions->sp[c] = 0;
+          }
+      }
+  
+      /**
+--- 1738,1814 ----
+              for (uint c = 0; c < g->nrChannels(); c++)
+                  minStorageDistributions->distributions->sp[c] = 0;
+          }
++ 
++ 	// close log file
++ 	#ifdef LOG_OUT
++ 	dseLog.close();
++ 	#endif
++ 	
++ 	// print DSE results
++ 	#ifdef VERBOSE_OUT
++ 	long int pp_counter = 0;
++ 	cout << "\nDSE RESULTS [START] (target throughput: " << maxThroughput
++ 	     << "):" << endl;
++ 
++ 	for (StorageDistributionSet *p = minStorageDistributions; p != NULL;
++ 	     p = p->next) {
++ 	  cout << "Printing storage distributions of distribution size: "
++ 	       << p->sz << endl;
++ 	  for (StorageDistribution *d = p->distributions; d != NULL;
++ 	       d = d->next) {
++ 	    pp_counter++;
++ 	    cout << "\tCurrent StorageDistribution info:" << endl;
++ 	    cout << "\tNumber of edges: " << g->nrChannels() << endl;
++ 	    cout << "\tChannel quantities:\n\t";
++ 	    for (uint c = 0; c < g->nrChannels(); c++) {
++ 	      if (g->getChannel(c)->getSrcActor()->getId() !=
++ 		  g->getChannel(c)->getDstActor()->getId()) {
++ 		cout << d->sp[g->getChannel(c)->getId()] << " ";
++ 	      }
++ 	    }
++ 	    cout << endl;
++ 	    cout << "\tDistribution size: " << d->sz << endl;
++ 	    cout << "\tThroughput: " << d->thr << endl;
++ 	  }
++ 	}
++ 	cout << "DSE RESULTS [END]" << endl;
++ 	cout << "Done with search!" << endl;
++ 	cout << "Number of computations: " << computation_counter << endl;
++ 	cout << "Number of pareto points: " << pp_counter << endl;
++ 	#endif
++ 
++ 	#ifdef LOG_OUT
++ 	// Variables for pareto point logging
++ 	ofstream ppLog;
++ 	ppLog.open(dirName + ppDirName + g->getName() + "_pp_sdf3.csv");
++ 	// Initialise log file
++ 	ppLog << "storage distribution size,throughput,channel quantities" << endl;
++ 	
++ 	for (StorageDistributionSet *p = minStorageDistributions; p != NULL;
++ 	     p = p->next) {
++ 	  for (StorageDistribution *d = p->distributions; d != NULL;
++ 	       d = d->next) {
++ 	    string output("\"");
++ 	    string delim("");
++ 	    uint noFeedbackSize = 0;
++ 	    for (uint c = 0; c < g->nrChannels(); c++) {
++ 	      if (g->getChannel(c)->getSrcActor()->getId() !=
++ 		  g->getChannel(c)->getDstActor()->getId()) {
++ 		output += delim;
++ 		output += to_string(d->sp[g->getChannel(c)->getId()]);
++ 		delim = ",";
++ 		noFeedbackSize += d->sp[g->getChannel(c)->getId()];
++ 	      }
++ 	    }
++ 	    output += "\"";
++ 	    ppLog << noFeedbackSize << ","
++ 		  << d->thr << ","
++ 		  << output << endl;
++ 	  }
++ 	}
++ 	ppLog.close();
++ 	#endif
++ 
+      }
+  
+      /**
+***************
+*** 1430,1435 ****
+          minStorageDistributions = NULL;
+  
+          // Initialize bounds on the search space
+          initBoundsSearchSpace(g);
+  
+          // Create a transition system
+--- 1828,1836 ----
+          minStorageDistributions = NULL;
+  
+          // Initialize bounds on the search space
++         #ifdef VERBOSE_OUT
++ 	cout << "INITIALISING SEARCH PARAMETERS:" << endl;
++         #endif
+          initBoundsSearchSpace(g);
+  
+          // Create a transition system
+*** selftimed_throughput.cc	2014-07-24 12:16:04.000000000 +0800
+--- selftimed_throughput.cc	2021-01-22 14:11:41.872482013 +0800
+***************
+*** 239,245
+              // Time between previous state
+              time += s.glbClk;
+          }
+! 
+          return (TDtime)(nr_fire) / (time);
+      }
+  
+--- 239,246 -----
+              // Time between previous state
+              time += s.glbClk;
+          }
+!         // cout << "total number execs: " << nr_fire
+!         //      << " total time: " << time << endl;
+          return (TDtime)(nr_fire) / (time);
+      }
+  
+*** sdf3analysis.cc	2014-07-24 12:16:04.000000000 +0800
+--- sdf3analysis.cc	2020-12-17 17:24:41.331274360 +0800
+***************
+*** 360,367
+  
+          // Measure execution time
+          stopTimer(&timer);
+!         out << "analysis time: ";
+!         printTimer(out, &timer);
+          out << endl;
+      }
+  
+--- 360,367 -----
+  
+          // Measure execution time
+          stopTimer(&timer);
+!         // out << "analysis time: ";
+!         // printTimer(out, &timer);
+          out << endl;
+      }
+  
+*** buffer.cc	2014-07-24 12:16:04.000000000 +0800
+--- buffer.cc	2021-01-21 15:28:09.061685107 +0800
+***************
+*** 38,46 ****
+  #include "buffer.h"
+  #include "../../base/algo/repetition_vector.h"
+  #include "../throughput/throughput.h"
+! 
+  namespace SDF
+  {
+      /******************************************************************************
+       * Bounds on the search space
+       *****************************************************************************/
+--- 38,57 ----
+  #include "buffer.h"
+  #include "../../base/algo/repetition_vector.h"
+  #include "../throughput/throughput.h"
+! // libraries for data logging
+! #include <chrono>
+! #include <string>
+! #define LOG_OUT // log data of DSE in CSVs
+  namespace SDF
+  {
++   // variables for data logging
++ #ifdef LOG_OUT
++   std::string dirName = std::getenv("SDF3LOGDIR");
++   std::string logDirName = "dse_logs/";
++   std::string ppDirName = "pp_logs/";
++   ofstream dseLog; // save search path data in DSE log
++   std::chrono::duration<double, std::milli> cumulativeTime;
++ #endif
+      /******************************************************************************
+       * Bounds on the search space
+       *****************************************************************************/
+***************
+*** 957,962 ****
+          //for (uint c = 0; c < g->nrChannels(); c++)
+          //    cerr << d->sp[c] << " " << d->dep[c] << endl;
+          //cerr << endl;
+      }
+  
+      /**
+--- 968,994 ----
+          //for (uint c = 0; c < g->nrChannels(); c++)
+          //    cerr << d->sp[c] << " " << d->dep[c] << endl;
+          //cerr << endl;
++ #ifdef LOG_OUT
++ 	// log dse data
++ 	std::string output("\"");
++ 	std::string delim("");
++ 	uint noFeedbackSize = 0;
++ 	for (SDFchannelsIter iter = g->channelsBegin();
++ 	     iter != g->channelsEnd(); iter++) {
++ 	  SDFchannel *c = *iter;
++ 	  if (c->getSrcActor()->getId() != c->getDstActor()->getId()) { // ignore feedback edges
++ 	    output += delim;
++ 	    output += std::to_string(d->sp[c->getId()]);
++ 	    delim = ",";
++ 	    noFeedbackSize += d->sp[c->getId()];
++ 	  }
++ 	}
++ 	output += "\"";
++ 
++ 	dseLog << noFeedbackSize << "," // distribution size
++ 	       << d->thr << "," // throughput
++ 	       << output << ","; // channel quantities
++ #endif
+      }
+  
+      /**
+***************
+*** 1152,1165 ****
+          StorageDistributionSet *ds, StorageDistribution *d)
+      {
+          StorageDistribution *dNew;
+! 
+          // Compute throughput and storage dependencies
+          execStorageDistribution(d);
+  
+          // Throughput of d larger then current maximum of the set
+          if (d->thr > ds->thr)
+              ds->thr = d->thr;
+  
+          // Create new storage distributions for every channel which
+          // has a storage dependency in d
+          for (uint c = 0; c < g->nrChannels(); c++)
+--- 1184,1210 ----
+          StorageDistributionSet *ds, StorageDistribution *d)
+      {
+          StorageDistribution *dNew;
+! #ifdef LOG_OUT
+! 	auto startTime = std::chrono::steady_clock::now();
+! #endif
+          // Compute throughput and storage dependencies
+          execStorageDistribution(d);
++ #ifdef LOG_OUT
++ 	auto endTime = std::chrono::steady_clock::now();
++ 	std::chrono::duration<double, std::milli> execTime = endTime - startTime; // duration of individual execution
++ 	cumulativeTime += execTime;
++ #endif
+  
+          // Throughput of d larger then current maximum of the set
+          if (d->thr > ds->thr)
+              ds->thr = d->thr;
+  
++ #ifdef LOG_OUT
++ 	// log execution times (cont. from execStorageDistribution)
++ 	dseLog << execTime.count() << ","
++ 	       << cumulativeTime.count() << endl;
++ #endif
++ 
+          // Create new storage distributions for every channel which
+          // has a storage dependency in d
+          for (uint c = 0; c < g->nrChannels(); c++)
+***************
+*** 1247,1252 ****
+          // Check sets of storage distributions till no distributions left to check,
+          // or throughput bound exceeded, or maximal throughput reached
+          ds = minStorageDistributions;
+          while (ds != NULL)
+          {
+              // Explore all distributions with size 'ds->sz'
+--- 1292,1303 ----
+          // Check sets of storage distributions till no distributions left to check,
+          // or throughput bound exceeded, or maximal throughput reached
+          ds = minStorageDistributions;
++         // Initialise log file
++ #ifdef LOG_OUT
++ 	dseLog.open(dirName + logDirName + g->getName() + "_dselog_sdf3.csv");
++ 	dseLog << "storage distribution size,throughput,channel quantities,computation duration,cumulative duration"
++ 	       << endl; // initialise headers
++ #endif
+          while (ds != NULL)
+          {
+              // Explore all distributions with size 'ds->sz'
diff -ruN sdf3_140724/sdf3/csdf/tools/sdf3analysis/sdf3analysis.cc sdf3_custom/sdf3/csdf/tools/sdf3analysis/sdf3analysis.cc
--- sdf3_140724/sdf3/csdf/tools/sdf3analysis/sdf3analysis.cc	2014-07-24 12:16:04.000000000 +0800
+++ sdf3_custom/sdf3/csdf/tools/sdf3analysis/sdf3analysis.cc	2022-04-13 21:25:58.260736328 +0800
@@ -293,6 +293,10 @@
                 out << " [" << g->getActor(i)->getName() << "] = ";
                 out << repetitionVector[i] << endl;
             }
+	    #ifdef VERBOSE_OUT
+	    cout << "Minimum channel size for " << ch->getName() << ": "
+		 << minSz[ch->getId()] << endl;
+	    #endif
         }
         else if (analyze.front().key == "repetition_vector_sum")
         {
@@ -357,11 +361,14 @@
         {
             throw CException("Unknown analysis algorithm.");
         }
+	#ifdef DEPS_OUT
+	cout << "\tAbstract dependency graph initialised" << endl;
+	#endif
 
         // Measure execution time
         stopTimer(&timer);
-        out << "analysis time: ";
-        printTimer(out, &timer);
+        // out << "analysis time: ";
+        // printTimer(out, &timer);
         out << endl;
     }
 
diff -ruN sdf3_140724/sdf3/csdf/tools/sdf3analysis/sdf3analysis.cc.orig sdf3_custom/sdf3/csdf/tools/sdf3analysis/sdf3analysis.cc.orig
--- sdf3_140724/sdf3/csdf/tools/sdf3analysis/sdf3analysis.cc.orig	1970-01-01 07:30:00.000000000 +0730
+++ sdf3_custom/sdf3/csdf/tools/sdf3analysis/sdf3analysis.cc.orig	2022-04-13 21:25:58.260736328 +0800
@@ -0,0 +1,431 @@
+/*
+ *  TU Eindhoven
+ *  Eindhoven, The Netherlands
+ *
+ *  Name            :   sdf3analysis.cc
+ *
+ *  Author          :   Sander Stuijk (sander@ics.ele.tue.nl)
+ *
+ *  Date            :   April 23, 2007
+ *
+ *  Function        :   (C)SDFG analysis algorithms
+ *
+ *  History         :
+ *      23-04-07    :   Initial version.
+ *
+ * $Id: sdf3analysis.cc,v 1.2.2.1 2009-03-26 15:58:13 mgeilen Exp $
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * In other words, you are welcome to use, share and improve this program.
+ * You are forbidden to forbid anyone else to use, share and improve
+ * what you give them.   Happy coding!
+ */
+
+#include "sdf3analysis.h"
+#include "sdf/sdf.h"
+#include "csdf/csdf.h"
+namespace CSDF
+{
+    typedef struct _CPair
+    {
+        CString key;
+        CString value;
+    } CPair;
+
+    typedef list<CPair>         CPairs;
+    typedef CPairs::iterator    CPairsIter;
+
+    /**
+     * Settings
+     * Struct to store program settings.
+     */
+    typedef struct _Settings
+    {
+        // Input file with graph
+        CString graphFile;
+
+        // Output file
+        CString outputFile;
+
+        // Switch argument(s) given to analysis algorithm
+        CPairs arguments;
+
+        // Application graph
+        CNode *xmlAppGraph;
+    } Settings;
+
+    /**
+     * settings
+     * Program settings.
+     */
+    Settings settings;
+
+    /**
+     * helpMessage ()
+     * Function prints help message for the tool.
+     */
+    void helpMessage(ostream &out)
+    {
+        out << "SDF3 " << TOOL << " (version " << DOTTED_VERSION ")" << endl;
+        out << endl;
+        out << "Usage: " << TOOL << " --graph <file> --algo <algorithm>";
+        out << " [--output <file>]";
+        out << endl;
+        out << "   --graph  <file>     input CSDF graph" << endl;
+        out << "   --output <file>     output file (default: stdout)" << endl;
+        out << "   --algo <algorithm>  analyze the graph with requested algorithm:";
+        out << endl;
+        out << "       consistency" << endl;
+        out << "       repetition_vector" << endl;
+        out << "       repetition_vector_sum" << endl;
+        out << "       throughput" << endl;
+        out << "       buffersize" << endl;
+    }
+
+    /**
+     * parseSwitchArgument ()
+     * The function parses the string 'arguments' into a sequence of (arg, value)
+     * pairs. The syntax as as follows:
+     *
+     * pair := key(value)
+     * arg := pair,pair,...
+     *
+     * Note: value may be a pair itself, but this is not expanded into a set of
+     * pairs (i.e. nested pairs are not supported).
+     */
+    CPairs parseSwitchArgument(CString arguments)
+    {
+        CPairs pairs;
+        CPair p;
+
+        while (arguments.size() != 0)
+        {
+            char c;
+            p.key = "";
+            p.value = "";
+
+            // Get key from argument string
+            do
+            {
+                c = arguments[0];
+                arguments = arguments.substr(1);
+                if (c == ',' || c == '(')
+                    break;
+                p.key += c;
+            }
+            while (arguments.size() != 0);
+
+            // Is next part of argument a value?
+            if (c == '(')
+            {
+                CString::size_type ePos = 0;
+                int level = 1;
+
+                // Find the matching closing brace
+                while (level != 0 && arguments.size() != 0)
+                {
+                    if (arguments.operator [](ePos) == ')')
+                        level--;
+                    else if (arguments.operator [](ePos) == '(')
+                        level++;
+
+                    // Next
+                    ePos++;
+                }
+
+                // Closing brace found?
+                if (level != 0)
+                    throw CException("Missing closing brace in value of argument.");
+
+                // Get value
+                p.value = arguments.substr(0, ePos - 1);
+
+                // More arguments left?
+                if (arguments.size() > ePos)
+                    arguments = arguments.substr(ePos + 1);
+                else
+                    arguments = "";
+            }
+
+            // Add pair to list of pairs
+            pairs.push_back(p);
+        }
+
+        return pairs;
+    }
+
+    /**
+     * parseCommandLine ()
+     * The function parses the command line arguments and add info to the
+     * supplied settings structure.
+     */
+    void parseCommandLine(int argc, char **argv)
+    {
+        int arg = 1;
+
+        if (argc == 1)
+        {
+            helpMessage(cerr);
+            throw CException("");
+        }
+
+        do
+        {
+            // Configuration file
+            if (argv[arg] == CString("--graph") && arg + 1 < argc)
+            {
+                arg++;
+                settings.graphFile = argv[arg];
+            }
+            else if (argv[arg] == CString("--output") && arg + 1 < argc)
+            {
+                arg++;
+                settings.outputFile = argv[arg];
+            }
+            else if (argv[arg] == CString("--algo") && arg + 1 < argc)
+            {
+                arg++;
+                settings.arguments = parseSwitchArgument(argv[arg]);
+            }
+            else
+            {
+                helpMessage(cerr);
+                throw CException("");
+            }
+
+            // Next argument
+            arg++;
+        }
+        while (arg < argc);
+    }
+
+    /**
+     * loadApplicationGraphFromFile ()
+     * The function returns a pointer to an XML data structures contained in the
+     * supplied file that describes the SDFG.
+     */
+    CNode *loadApplicationGraphFromFile(CString &file, CString module)
+    {
+        CNode *appGraphNode, *sdf3Node;
+        CDoc *appGraphDoc;
+
+        // Open file
+        appGraphDoc = CParseFile(file);
+        if (appGraphDoc == NULL)
+            throw CException("Failed loading application from '" + file + "'.");
+
+        // Locate the sdf3 root element and check module type
+        sdf3Node = CGetRootNode(appGraphDoc);
+        if (CGetAttribute(sdf3Node, "type") != module)
+        {
+            throw CException("Root element in file '" + file + "' is not "
+                             "of type '" + module + "'.");
+        }
+
+        // Get application graph node
+        appGraphNode = CGetChildNode(sdf3Node, "applicationGraph");
+        if (appGraphNode == NULL)
+            throw CException("No application graph in '" + file + "'.");
+
+        return appGraphNode;
+    }
+
+    /**
+     * initSettings ()
+     * The function initializes the program settings.
+     */
+    void initSettings(int argc, char **argv)
+    {
+        // Parse the command line
+        parseCommandLine(argc, argv);
+
+        // Check required settings
+        if (settings.graphFile.empty() || settings.arguments.size() == 0)
+        {
+            helpMessage(cerr);
+            throw CException("");
+        }
+
+        // Load application graph
+        settings.xmlAppGraph = loadApplicationGraphFromFile(settings.graphFile,
+                               MODULE);
+    }
+
+    /**
+     * analyzeCSDFG ()
+     * The function analyzes the CSDF graph.
+     */
+    void analyzeCSDFG(TimedCSDFgraph *g, CPairs &analyze, ostream &out)
+    {
+        CTimer timer;
+
+        // Measure execution time
+        startTimer(&timer);
+
+        // Run analysis
+        if (analyze.front().key == "consistency")
+        {
+            if (!g->isConsistent())
+                out << "Graph is not consistent." << endl;
+            else
+                out << "Graph is consistent." << endl;
+        }
+        else if (analyze.front().key == "repetition_vector")
+        {
+            RepetitionVector repetitionVector;
+            repetitionVector = g->getRepetitionVector();
+
+            out << "Repetition vector:" << endl;
+            for (uint i = 0; i < repetitionVector.size(); i++)
+            {
+                out << " [" << g->getActor(i)->getName() << "] = ";
+                out << repetitionVector[i] << endl;
+            }
+	    #ifdef VERBOSE_OUT
+	    cout << "Minimum channel size for " << ch->getName() << ": "
+		 << minSz[ch->getId()] << endl;
+	    #endif
+        }
+        else if (analyze.front().key == "repetition_vector_sum")
+        {
+            uint sum = 0;
+
+            RepetitionVector repetitionVector;
+            repetitionVector = g->getRepetitionVector();
+
+            for (uint i = 0; i < repetitionVector.size(); i++)
+                sum += repetitionVector[i];
+
+            out << "Repetition vector sum: " << sum << endl;
+        }
+        else if (analyze.front().key == "throughput")
+        {
+            CSDFstateSpaceThroughputAnalysis thrAlgo;
+            double thr;
+
+            thr = thrAlgo.analyze(g);
+            out << "thr(" << g->getName() << ") = " << thr << endl;
+        }
+        else if (analyze.front().key == "buffersize")
+        {
+            StorageDistributionSet *minStorageDistributions;
+            CSDFstateSpaceBufferAnalysis bufferAlgo;
+
+            // Explore trade-off space
+            minStorageDistributions = bufferAlgo.analyze(g);
+
+            out << "<?xml version='1.0' encoding='UTF-8'?>" << endl;
+            out << "<sdf3 type='sdf' version='1.0'" << endl;
+            out << "     xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'";
+            out << endl;
+            out << "     xsi:noNamespaceSchemaLocation='http://www.es.ele.tue.nl/sdf3/xsd/sdf3-csdf.xsd'>" << endl;
+            out << "    <storageThroughputTradeOffs>" << endl;
+
+            for (StorageDistributionSet *p = minStorageDistributions; p != NULL;
+                 p = p->next)
+            {
+                out << "        <distributionsSet thr='";
+                out << p->thr;
+                out << "' sz='" << p->sz << "'>" << endl;
+                for (StorageDistribution *d = p->distributions;
+                     d != NULL; d = d->next)
+                {
+                    out << "            <distribution>" << endl;
+                    for (uint c = 0; c < g->nrChannels(); c++)
+                    {
+                        out << "                <ch name='";
+                        out << g->getChannel(c)->getName();
+                        out << "' sz='" << d->sp[c];
+                        out << "'/>" << endl;
+                    }
+                    out << "            </distribution>" << endl;
+                }
+                out << "        </distributionsSet>" << endl;
+            }
+            out << "    </storageThroughputTradeOffs>" << endl;
+            out << "</sdf3>" << endl;
+        }
+        else
+        {
+            throw CException("Unknown analysis algorithm.");
+        }
+	#ifdef DEPS_OUT
+	cout << "\tAbstract dependency graph initialised" << endl;
+	#endif
+
+        // Measure execution time
+        stopTimer(&timer);
+        // out << "analysis time: ";
+        // printTimer(out, &timer);
+        out << endl;
+    }
+
+    /**
+     * analyzeCSDFG ()
+     * The function analyzes the CSDF graph.
+     */
+    void analyzeCSDFG(ostream &out)
+    {
+        CNode *csdfNode, *csdfPropertiesNode;
+        TimedCSDFgraph *csdfGraph;
+
+        // Find csdf graph in XML structure
+        csdfNode = CGetChildNode(settings.xmlAppGraph, "csdf");
+        if (csdfNode == NULL)
+            throw CException("Invalid xml file - missing 'csdf' node");
+        csdfPropertiesNode = CGetChildNode(settings.xmlAppGraph, "csdfProperties");
+
+        // Construction CSDF graph model
+        csdfGraph = constructTimedCSDFgraph(csdfNode, csdfPropertiesNode);
+
+        // The actual analysis...
+        analyzeCSDFG(csdfGraph, settings.arguments, out);
+
+        // Cleanup
+        delete csdfGraph;
+    }
+} // namespace CSDF
+/**
+ * main ()
+ * It does none of the hard work, but it is very needed...
+ */
+int main(int argc, char **argv)
+{
+    int exit_status = 0;
+    ofstream out;
+
+    try
+    {
+        // Initialize the program
+        initSettings(argc, argv);
+
+        // Set output stream
+        if (!settings.outputFile.empty())
+            out.open(settings.outputFile.c_str());
+        else
+            ((ostream &)(out)).rdbuf(cout.rdbuf());
+
+        // Perform requested actions
+        analyzeCSDFG(out);
+    }
+    catch (CException &e)
+    {
+        cerr << e;
+        exit_status = 1;
+    }
+
+    return exit_status;
+}
+
diff -ruN sdf3_140724/sdf3/csdf/tools/sdf3analysis/sdf3analysis.cc.rej sdf3_custom/sdf3/csdf/tools/sdf3analysis/sdf3analysis.cc.rej
--- sdf3_140724/sdf3/csdf/tools/sdf3analysis/sdf3analysis.cc.rej	1970-01-01 07:30:00.000000000 +0730
+++ sdf3_custom/sdf3/csdf/tools/sdf3analysis/sdf3analysis.cc.rej	2022-04-13 21:25:58.260736328 +0800
@@ -0,0 +1,1517 @@
+*** buffer.cc	2014-07-24 12:16:04.000000000 +0800
+--- buffer.cc	2021-01-21 15:26:47.935610418 +0800
+***************
+*** 37,44 ****
+  
+  #include "buffer.h"
+  #include "../throughput/throughput.h"
+  namespace CSDF
+  {
+  
+      /******************************************************************************
+       * Bounds on the search space
+--- 37,62 ----
+  
+  #include "buffer.h"
+  #include "../throughput/throughput.h"
++ // libraries for data logging
++ #include <chrono>
++ // define variables to toggle verbose/extremely verbose/logging
++ // #define VERBOSE_OUT // print out explored storage distributions and results
++ // #define DEPS_OUT // extremely verbose output --- useful for understanding implementation of symbolic execution and storage deps
++ #define LOG_OUT // log data of DSE in CSVs
++ 
+  namespace CSDF
+  {
++   #ifdef VERBOSE_OUT
++   long int computation_counter = 0;
++   #endif
++   // variables for data logging
++   #ifdef LOG_OUT
++   string dirName = std::getenv("SDF3LOGDIR");
++   string logDirName = "dse_logs/";
++   string ppDirName = "pp_logs/";
++   ofstream dseLog; // save search path data in DSE log
++   std::chrono::duration<double, milli> cumulativeTime;
++   #endif
+  
+      /******************************************************************************
+       * Bounds on the search space
+***************
+*** 62,67 ****
+       */
+      void CSDFstateSpaceBufferAnalysis::initMinimalChannelSzStep(TimedCSDFgraph *g)
+      {
+          minSzStep = new TBufSize [g->nrChannels()];
+  
+          for (CSDFchannelsIter iter = g->channelsBegin(); iter != g->channelsEnd();
+--- 80,88 ----
+       */
+      void CSDFstateSpaceBufferAnalysis::initMinimalChannelSzStep(TimedCSDFgraph *g)
+      {
++       #ifdef VERBOSE_OUT
++       cout << "Calculating minimal channel step sizes..." << endl;
++       #endif
+          minSzStep = new TBufSize [g->nrChannels()];
+  
+          for (CSDFchannelsIter iter = g->channelsBegin(); iter != g->channelsEnd();
+***************
+*** 84,89 ****
+                  minStepSz = gcd(minStepSz, dstPort->getRate()[i]);
+  
+              minSzStep[ch->getId()] = minStepSz;
+          }
+      }
+  
+--- 105,114 ----
+                  minStepSz = gcd(minStepSz, dstPort->getRate()[i]);
+  
+              minSzStep[ch->getId()] = minStepSz;
++ 	    #ifdef VERBOSE_OUT
++ 	    cout << "Min. step size for channel " << ch->getName() << ": "
++ 		 << minStepSz << endl;
++ 	    #endif
+          }
+      }
+  
+***************
+*** 93,98 ****
+       */
+      void CSDFstateSpaceBufferAnalysis::initMinimalChannelSz(TimedCSDFgraph *g)
+      {
+          minSz =  new TBufSize [g->nrChannels()];
+  
+          for (CSDFchannelsIter iter = g->channelsBegin(); iter != g->channelsEnd();
+--- 118,126 ----
+       */
+      void CSDFstateSpaceBufferAnalysis::initMinimalChannelSz(TimedCSDFgraph *g)
+      {
++       #ifdef VERBOSE_OUT
++       cout << "Calculating minimal channel sizes (for positive throughput)..." << endl;
++       #endif
+          minSz =  new TBufSize [g->nrChannels()];
+  
+          for (CSDFchannelsIter iter = g->channelsBegin(); iter != g->channelsEnd();
+***************
+*** 116,121 ****
+                  uint t = ch->getInitialTokens();
+                  uint lb;
+  
+                  // Lower-bound of a self-edge is rate at which data is produced and
+                  // consumed and the number of initial tokens present
+                  if (ch->getSrcActor()->getId() == ch->getDstActor()->getId())
+--- 144,152 ----
+                  uint t = ch->getInitialTokens();
+                  uint lb;
+  
++ 		#ifdef VERBOSE_OUT
++ 		cout << "p, c, t: " << p << ", " << c << ", " << t << endl;
++ 		#endif
+                  // Lower-bound of a self-edge is rate at which data is produced and
+                  // consumed and the number of initial tokens present
+                  if (ch->getSrcActor()->getId() == ch->getDstActor()->getId())
+***************
+*** 151,156 ****
+  
+          for (uint c = 0; c < g->nrChannels(); c++)
+              lbDistributionSz += minSz[c];
+      }
+  
+      /**
+--- 186,194 ----
+  
+          for (uint c = 0; c < g->nrChannels(); c++)
+              lbDistributionSz += minSz[c];
++ 	#ifdef VERBOSE_OUT
++ 	cout << "Lower bound distribution size: " << lbDistributionSz << endl;
++ 	#endif
+      }
+  
+      /**
+***************
+*** 162,167 ****
+          CSDFstateSpaceThroughputAnalysis thrAnalysisAlgo;
+  
+          maxThroughput = thrAnalysisAlgo.analyze(g);
+      }
+  
+      /******************************************************************************
+--- 200,208 ----
+          CSDFstateSpaceThroughputAnalysis thrAnalysisAlgo;
+  
+          maxThroughput = thrAnalysisAlgo.analyze(g);
++ 	#ifdef VERBOSE_OUT
++ 	cout << "Max throughput: " << maxThroughput << endl;
++ 	#endif
+      }
+  
+      /******************************************************************************
+***************
+*** 354,360 ****
+              // Time between previous state
+              time += s.glbClk;
+          }
+! 
+          return (TDtime)(nr_fire) / (time);
+      }
+  
+--- 395,406 ----
+              // Time between previous state
+              time += s.glbClk;
+          }
+! 	#ifdef DEPS_OUT
+! 	cout << "\nComputing throughput..."
+! 	     << "\nNumber of executions: " << nr_fire
+! 	     << "\nPeriod length: " << time
+! 	     << endl;
+! 	#endif
+          return (TDtime)(nr_fire) / (time);
+      }
+  
+***************
+*** 386,391 ****
+                  if (color[b] == 1)
+                  {
+                      // Found a cycle in the graph containing node b
+                      c = a;
+                      d = b;
+                      do
+--- 432,441 ----
+                  if (color[b] == 1)
+                  {
+                      // Found a cycle in the graph containing node b
++ 		  #ifdef DEPS_OUT
++ 		  cout << "\t\t\t\t Found cycle in abstract dep graph containing node from actor "
++ 		       << g->getActor(a)->getName() << " and actor " << g->getActor(b)->getName() << endl;
++ 		  #endif
+                      c = a;
+                      d = b;
+                      do
+***************
+*** 400,406 ****
+                              CId dstId = ch->getDstActor()->getId();
+  
+                              if (dstId == d && srcId == c)
+                                  dep[ch->getId()] = true;
+                          }
+  
+                          // Next
+--- 450,461 ----
+                              CId dstId = ch->getDstActor()->getId();
+  
+                              if (dstId == d && srcId == c)
++ 			      {
++ 				#ifdef DEPS_OUT
++ 				cout << "\t\t\t\t  Storage dependency found in channel " << ch->getName() << endl;
++ 				#endif
+                                  dep[ch->getId()] = true;
++ 			      }
+                          }
+  
+                          // Next
+***************
+*** 524,529 ****
+      void CSDFstateSpaceBufferAnalysis::TransitionSystem::startActorFiring(
+          TimedCSDFactor *a)
+      {
+          // Consume tokens from inputs and space for output tokens
+          for (CSDFportsIter iter = a->portsBegin(); iter != a->portsEnd(); iter++)
+          {
+--- 579,587 ----
+      void CSDFstateSpaceBufferAnalysis::TransitionSystem::startActorFiring(
+          TimedCSDFactor *a)
+      {
++       #ifdef DEPS_OUT
++       cout << "Start firing of actor " << a->getName() << endl;
++       #endif
+          // Consume tokens from inputs and space for output tokens
+          for (CSDFportsIter iter = a->portsBegin(); iter != a->portsEnd(); iter++)
+          {
+***************
+*** 533,552 ****
+              // Actor is destination of the channel?
+              if (p->getType() == CSDFport::In)
+              {
+                  CONSUME(c->getId(), p->getRate()[ACT_SEQ_POS(a->getId())]);
+              }
+              else
+              {
+!                 CONSUME_SP(c->getId(), p->getRate()[ACT_SEQ_POS(a->getId())]);
+              }
+          }
+  
+          // Add actor firing to the list of active firings of this actor
+          currentState.actClk[a->getId()].push_back(
+              a->getExecutionTime()[ACT_SEQ_POS(a->getId())]);
+  
+          // Advance the sequence position of the actor
+          ACT_SEQ_POS(a->getId()) = (ACT_SEQ_POS(a->getId()) + 1) % a->sequenceLength();
+      }
+  
+      /**
+--- 591,627 ----
+              // Actor is destination of the channel?
+              if (p->getType() == CSDFport::In)
+              {
++ 	      #ifdef DEPS_OUT
++ 	      cout << "\tConsume " << p->getRate()[ACT_SEQ_POS(a->getId())]
++ 		   << " tokens from channel " << c->getName() << endl;
++ 	      #endif
+                  CONSUME(c->getId(), p->getRate()[ACT_SEQ_POS(a->getId())]);
+              }
+              else
+              {
+! 	      #ifdef DEPS_OUT
+! 	      cout << "\tSpace in channel " << c->getName() << " reduced by "
+! 		   << p->getRate()[ACT_SEQ_POS(a->getId())] << endl;
+! 	      #endif
+! 	      CONSUME_SP(c->getId(), p->getRate()[ACT_SEQ_POS(a->getId())]);
+              }
+          }
+  
+          // Add actor firing to the list of active firings of this actor
+          currentState.actClk[a->getId()].push_back(
+              a->getExecutionTime()[ACT_SEQ_POS(a->getId())]);
++ 	#ifdef DEPS_OUT
++ 	cout << "\t\tAdd actor firing to list of active firings of actor:" << endl;
++ 	cout << "\t\tExecution time of " << a->getExecutionTime()[ACT_SEQ_POS(a->getId())]
++ 	     << " added" << endl;
++ 	#endif
+  
+          // Advance the sequence position of the actor
+          ACT_SEQ_POS(a->getId()) = (ACT_SEQ_POS(a->getId()) + 1) % a->sequenceLength();
++ 	#ifdef DEPS_OUT
++ 	cout << "\t\tActor is now in phase " << ACT_SEQ_POS(a->getId()) << endl;
++ 	currentState.print(cout);
++ 	#endif
+      }
+  
+      /**
+***************
+*** 575,580 ****
+      void CSDFstateSpaceBufferAnalysis::TransitionSystem::endActorFiring(
+          CSDFactor *a)
+      {
+          for (CSDFportsIter iter = a->portsBegin(); iter != a->portsEnd(); iter++)
+          {
+              CSDFport *p = *iter;
+--- 650,658 ----
+      void CSDFstateSpaceBufferAnalysis::TransitionSystem::endActorFiring(
+          CSDFactor *a)
+      {
++       #ifdef DEPS_OUT
++       cout << "End firing of actor " << a->getName() << endl;
++       #endif
+          for (CSDFportsIter iter = a->portsBegin(); iter != a->portsEnd(); iter++)
+          {
+              CSDFport *p = *iter;
+***************
+*** 588,603 ****
+              // Actor is source of the channel?
+              if (p->getType() == CSDFport::Out)
+              {
+!                 PRODUCE(c->getId(), p->getRate()[seqPos]);
+              }
+              else
+              {
+                  PRODUCE_SP(c->getId(), p->getRate()[seqPos]);
+              }
+          }
+  
+          // Remove the firing from the list of active actor firings
+          currentState.actClk[a->getId()].pop_front();
+      }
+  
+      /**
+--- 666,693 ----
+              // Actor is source of the channel?
+              if (p->getType() == CSDFport::Out)
+              {
+! 	      #ifdef DEPS_OUT
+! 	      cout << "\tProduce " << p->getRate()[seqPos]
+! 		   << " tokens into channel " << c->getName() << endl;
+! 	      #endif
+! 	      PRODUCE(c->getId(), p->getRate()[seqPos]);
+              }
+              else
+              {
++ 	      #ifdef DEPS_OUT
++ 	      cout << "\tSpace in channel " << c->getName() << " increased by "
++ 		   << p->getRate()[seqPos] << endl;
++ 	      #endif
+                  PRODUCE_SP(c->getId(), p->getRate()[seqPos]);
+              }
+          }
+  
+          // Remove the firing from the list of active actor firings
+          currentState.actClk[a->getId()].pop_front();
++ 	#ifdef DEPS_OUT
++ 	cout << "\t\tRemove actor firing to list of active firings of actor" << endl;
++         currentState.print(cout);
++ 	#endif
+      }
+  
+      /**
+***************
+*** 673,678 ****
+                  if (!CH_TOKENS_PREV(c->getId(),
+                                      p->getRate()[ACT_SEQ_POS(a->getId())]))
+                  {
+                      abstractDepGraph[dstActor->getId()][srcActor->getId()] = true;
+                  }
+              }
+--- 763,779 ----
+                  if (!CH_TOKENS_PREV(c->getId(),
+                                      p->getRate()[ACT_SEQ_POS(a->getId())]))
+                  {
++ 		  #ifdef DEPS_OUT
++ 		  cout << "\t\t\t\tFound causal dependency in channel " << c->getName()
++ 		       << ": not enough tokens in previous state (needed at least "
++ 		       << p->getRate()[ACT_SEQ_POS(a->getId())] << " tokens)" << endl;
++ 		  cout << "Previous state:" << endl;
++ 		  previousState.print(cout);
++ 		  cout << endl;
++ 		  cout << "Current state:" << endl;
++ 		  currentState.print(cout);
++ 		  cout << endl;
++ 		  #endif
+                      abstractDepGraph[dstActor->getId()][srcActor->getId()] = true;
+                  }
+              }
+***************
+*** 682,687 ****
+                  if (!CH_SPACE_PREV(c->getId(),
+                                     p->getRate()[ACT_SEQ_POS(a->getId())]))
+                  {
+                      abstractDepGraph[srcActor->getId()][dstActor->getId()] = true;
+                  }
+              }
+--- 783,799 ----
+                  if (!CH_SPACE_PREV(c->getId(),
+                                     p->getRate()[ACT_SEQ_POS(a->getId())]))
+                  {
++ 		  #ifdef DEPS_OUT
++ 		  cout << "\t\t\t\tFound causal dependency in channel " << c->getName()
++ 		       << ": not enough space in previous state (needed at least "
++ 		       << p->getRate()[ACT_SEQ_POS(a->getId())] << " space)" << endl;
++ 		  cout << "Previous state:" << endl;
++ 		  previousState.print(cout);
++ 		  cout << endl;
++ 		  cout << "Current state:" << endl;
++ 		  currentState.print(cout);
++ 		  cout << endl;
++ 		  #endif
+                      abstractDepGraph[srcActor->getId()][dstActor->getId()] = true;
+                  }
+              }
+***************
+*** 712,737 ****
+              for (uint j = 0; j < g->nrActors(); j++)
+                  abstractDepGraph[i][j] = false;
+          }
+  
+          // Start new iteration of the periodic phase
+          currentState.glbClk = 0;
+  
+          // Still need to complete the last firing of the output actor
+          // before period really ends
+!         repCnt = -1;
+  
+          // Complete the remaining actor firings
+          for (CSDFactorsIter iter = g->actorsBegin(); iter != g->actorsEnd(); iter++)
+          {
+              CSDFactor *a = *iter;
+  
+              while (actorReadyToEnd(a))
+              {
+                  if (a->getId() == outputActor->getId())
+                  {
+                      repCnt++;
+                      if (repCnt == outputActorRepCnt)
+                      {
+                          currentState.glbClk = 0;
+                          repCnt = 0;
+                      }
+--- 824,869 ----
+              for (uint j = 0; j < g->nrActors(); j++)
+                  abstractDepGraph[i][j] = false;
+          }
++ 	#ifdef DEPS_OUT
++ 	cout << "\t\t\tAbstract dependency graph initialised" << endl;
++ 	#endif
+  
+          // Start new iteration of the periodic phase
+          currentState.glbClk = 0;
++ 	#ifdef DEPS_OUT
++ 	cout << "\t\t\tReset global clock for new iteration of periodic phase:" << endl;
++ 	currentState.print(cout);
++ 	#endif
+  
+          // Still need to complete the last firing of the output actor
+          // before period really ends
+!         repCnt = -1; // so that output actor is executed one more time
+  
+          // Complete the remaining actor firings
++ 	#ifdef DEPS_OUT
++ 	cout << "\t\t\tCompleting remaining actor firings" << endl;
++ 	#endif
+          for (CSDFactorsIter iter = g->actorsBegin(); iter != g->actorsEnd(); iter++)
+          {
+              CSDFactor *a = *iter;
+  
+              while (actorReadyToEnd(a))
+              {
++ 	      #ifdef DEPS_OUT
++ 	      cout << "\n\t\t\tActor " << a->getName() << " ready to end...." << endl;
++ 	      #endif
+                  if (a->getId() == outputActor->getId())
+                  {
+                      repCnt++;
++ 		    #ifdef DEPS_OUT
++ 		    cout << "\t\t\tActor is output actor (has lowest rep vector value): incrementing repCnt to: "
++ 			 << repCnt << endl;
++ 		    #endif
+                      if (repCnt == outputActorRepCnt)
+                      {
++ 		      #ifdef DEPS_OUT
++ 		      cout << "\t\t\trepCnt equal to outputActorRepCnt: reset currentState.glbClk and repCnt to 0" << endl;
++ 		      #endif
+                          currentState.glbClk = 0;
+                          repCnt = 0;
+                      }
+***************
+*** 753,758 ****
+                  // Ready to fire actor a?
+                  while (actorReadyToFire(a))
+                  {
+                      // Track causal dependencies on firing of actor a
+                      findCausalDependencies(a, abstractDepGraph);
+  
+--- 885,894 ----
+                  // Ready to fire actor a?
+                  while (actorReadyToFire(a))
+                  {
++ 		  #ifdef DEPS_OUT
++ 		  cout << "\n\t\t\tActor " << a->getName() << " ready to fire" << endl;
++ 		  cout << "\t\t\tFind causal dependencies for this actor" << endl;
++ 		  #endif
+                      // Track causal dependencies on firing of actor a
+                      findCausalDependencies(a, abstractDepGraph);
+  
+***************
+*** 764,769 ****
+              // Clock step
+              clockStep();
+  
+              // Store partial state to check for progress
+              for (uint i = 0; i < g->nrChannels(); i++)
+              {
+--- 900,908 ----
+              // Clock step
+              clockStep();
+  
++ 	    #ifdef DEPS_OUT
++ 	    cout << "\t\t\tStoring partial state by setting current state ch and sp to prev state" << endl;
++ 	    #endif
+              // Store partial state to check for progress
+              for (uint i = 0; i < g->nrChannels(); i++)
+              {
+***************
+*** 772,777 ****
+              }
+  
+              // Finish actor firings
+              for (CSDFactorsIter iter = g->actorsBegin();
+                   iter != g->actorsEnd(); iter++)
+              {
+--- 911,919 ----
+              }
+  
+              // Finish actor firings
++ 	    #ifdef DEPS_OUT
++ 	    cout << "\t\t\tFinish actor firings" << endl;
++ 	    #endif
+              for (CSDFactorsIter iter = g->actorsBegin();
+                   iter != g->actorsEnd(); iter++)
+              {
+***************
+*** 779,792 ****
+  
+                  while (actorReadyToEnd(a))
+                  {
+                      if (outputActor->getId() == a->getId())
+                      {
+                          repCnt++;
+                          if (repCnt == outputActorRepCnt)
+                          {
+                              // Found periodic state
+                              if (currentState == periodicState)
+                              {
+                                  // Cycles in the dependency graph indicate storage
+                                  // dependencies
+                                  findStorageDependencies(abstractDepGraph, dep);
+--- 921,948 ----
+  
+                  while (actorReadyToEnd(a))
+                  {
++ 		  #ifdef DEPS_OUT
++ 		  cout << "\n\t\t\tActor " << a->getName() << " ready to end...." << endl;
++ 		  #endif
+                      if (outputActor->getId() == a->getId())
+                      {
+                          repCnt++;
++ 			#ifdef DEPS_OUT
++ 			cout << "\t\t\tActor is output actor (has lowest rep vector value): incrementing repCnt to: "
++ 			     << repCnt << endl;
++ 			#endif
+                          if (repCnt == outputActorRepCnt)
+                          {
++ 			  #ifdef DEPS_OUT
++ 			  cout << "\t\t\trepCnt equal to outputActorRepCnt:" << endl;
++ 			  #endif
+                              // Found periodic state
+                              if (currentState == periodicState)
+                              {
++ 			      #ifdef DEPS_OUT
++ 			      cout << "\t\t\tCurrent state is the periodic state" << endl;
++ 			      cout << "\t\t\t\tLook for storage dependencies (cycles in abstract dependency graph)" << endl;
++ 			      #endif
+                                  // Cycles in the dependency graph indicate storage
+                                  // dependencies
+                                  findStorageDependencies(abstractDepGraph, dep);
+***************
+*** 799,804 ****
+                                  // Done
+                                  return;
+                              }
+                              currentState.glbClk = 0;
+                              repCnt = 0;
+                          }
+--- 955,963 ----
+                                  // Done
+                                  return;
+                              }
++ 			    #ifdef DEPS_OUT
++ 			    cout << "Reset currentState.glbClk and repCnt to 0" << endl;
++ 			    #endif
+                              currentState.glbClk = 0;
+                              repCnt = 0;
+                          }
+***************
+*** 844,849 ****
+              if (!CH_TOKENS(c->getId(),
+                             c->getDstPort()->getRate()[ACT_SEQ_POS(dstActor->getId())]))
+              {
+                  abstractDepGraph[dstActor->getId()][srcActor->getId()] = true;
+              }
+  
+--- 1006,1017 ----
+              if (!CH_TOKENS(c->getId(),
+                             c->getDstPort()->getRate()[ACT_SEQ_POS(dstActor->getId())]))
+              {
++ 	      #ifdef DEPS_OUT
++ 	      cout << "\t\tFound causal dependency in channel " << c->getName()
++ 		   << ": not enough tokens to fire destination actor " << dstActor->getName()
++ 		   << " (needed at least " << c->getDstPort()->getRate()[ACT_SEQ_POS(dstActor->getId())]
++ 		   << " tokens)" << endl;
++ 	      #endif
+                  abstractDepGraph[dstActor->getId()][srcActor->getId()] = true;
+              }
+  
+***************
+*** 851,856 ****
+              if (!CH_SPACE(c->getId(),
+                            c->getSrcPort()->getRate()[ACT_SEQ_POS(srcActor->getId())]))
+              {
+                  abstractDepGraph[srcActor->getId()][dstActor->getId()] = true;
+              }
+          }
+--- 1019,1030 ----
+              if (!CH_SPACE(c->getId(),
+                            c->getSrcPort()->getRate()[ACT_SEQ_POS(srcActor->getId())]))
+              {
++ 	      #ifdef DEPS_OUT
++ 	      cout << "\t\tFound causal dependency in channel " << c->getName()
++ 		   << ": not enough space to fire source actor " << srcActor->getName()
++ 		   << " (needed at least " << c->getSrcPort()->getRate()[ACT_SEQ_POS(dstActor->getId())]
++ 		   << " space)" << endl;
++ 	      #endif
+                  abstractDepGraph[srcActor->getId()][dstActor->getId()] = true;
+              }
+          }
+***************
+*** 880,885 ****
+          clearStoredStates();
+  
+          // Create initial state
+          currentState.init(g->nrActors(), g->nrChannels());
+          currentState.clear();
+          previousState.init(g->nrActors(), g->nrChannels());
+--- 1054,1063 ----
+          clearStoredStates();
+  
+          // Create initial state
++ 	#ifdef DEPS_OUT
++ 	cout << "Initialising previous and current states with " << to_string(g->nrActors())
++ 	     << " actors and " << to_string(g->nrChannels()) << " channels" << endl;
++ 	#endif
+          currentState.init(g->nrActors(), g->nrChannels());
+          currentState.clear();
+          previousState.init(g->nrActors(), g->nrChannels());
+***************
+*** 898,908 ****
+                  return 0;
+              }
+  
+              CH(c->getId()) = c->getInitialTokens();
+              SP(c->getId()) = sp[c->getId()] - c->getInitialTokens();
+          }
+  
+          // Fire the actors
+          while (true)
+          {
+              // Store partial state to check for progress
+--- 1076,1097 ----
+                  return 0;
+              }
+  
++ 	    #ifdef DEPS_OUT
++ 	    cout << "Setting initial tokens and space for channel: " << c->getName() << " ("
++ 		 << c->getInitialTokens() << ", " << sp[c->getId()] - c->getInitialTokens()
++ 		 << ")" << endl;
++ 	    #endif
+              CH(c->getId()) = c->getInitialTokens();
+              SP(c->getId()) = sp[c->getId()] - c->getInitialTokens();
++ 	    #ifdef DEPS_OUT
++ 	    c->print(cout);
++ 	    #endif
+          }
+  
+          // Fire the actors
++ 	#ifdef DEPS_OUT
++ 	cout << "\nBegin actor firings" << endl;
++ 	#endif
+          while (true)
+          {
+              // Store partial state to check for progress
+***************
+*** 920,934 ****
+  
+                  while (actorReadyToEnd(a))
+                  {
+                      if (outputActor->getId() == a->getId())
+                      {
+                          repCnt++;
+                          if (repCnt == outputActorRepCnt)
+                          {
+                              // Add state to hash of visited states
+                              if (!storeState(currentState, recurrentState))
+                              {
+!                                 // Find storage dependencies in periodic phase
+                                  analyzePeriodicPhase(sp, dep);
+  
+                                  return computeThroughput(recurrentState);
+--- 1109,1136 ----
+  
+                  while (actorReadyToEnd(a))
+                  {
++ 		  #ifdef DEPS_OUT
++ 		  cout << "\nActor " << a->getName() << " ready to end...." << endl;
++ 		  #endif
+                      if (outputActor->getId() == a->getId())
+                      {
+                          repCnt++;
++ 			#ifdef DEPS_OUT
++ 			cout << "\tActor is output actor (has lowest rep vector value): incrementing repCnt to: "
++ 			     << repCnt << endl;
++ 			#endif
+                          if (repCnt == outputActorRepCnt)
+                          {
++ 			  #ifdef DEPS_OUT
++ 			  cout << "\t\trepCnt equal to outputActorRepCnt" << endl;
++ 			  #endif
+                              // Add state to hash of visited states
+                              if (!storeState(currentState, recurrentState))
+                              {
+! 			      // Find storage dependencies in periodic phase
+! 			      #ifdef DEPS_OUT
+! 			      cout << "\t\tCurrent state has been visited before: analyse periodic phase" << endl;
+! 			      #endif
+                                  analyzePeriodicPhase(sp, dep);
+  
+                                  return computeThroughput(recurrentState);
+***************
+*** 952,957 ****
+                  // Ready to fire actor a?
+                  while (actorReadyToFire(a))
+                  {
+                      // Fire actor a
+                      startActorFiring(a);
+                  }
+--- 1154,1162 ----
+                  // Ready to fire actor a?
+                  while (actorReadyToFire(a))
+                  {
++ 		  #ifdef DEPS_OUT
++ 		  cout << "\nActor " << a->getName() << " ready to fire" << endl;
++ 		  #endif
+                      // Fire actor a
+                      startActorFiring(a);
+                  }
+***************
+*** 959,968 ****
+  
+              // Clock step
+              clkStep = clockStep();
+  
+              // Deadlocked?
+              if (clkStep == UINT_MAX)
+              {
+                  // Find cause of deadlock
+                  analyzeDeadlock(sp, dep);
+                  return 0;
+--- 1164,1179 ----
+  
+              // Clock step
+              clkStep = clockStep();
++ 	    #ifdef DEPS_OUT
++ 	    cout << "clkStep set to " << clkStep << endl;
++ 	    #endif
+  
+              // Deadlocked?
+              if (clkStep == UINT_MAX)
+              {
++ 	      #ifdef DEPS_OUT
++ 	      cout << "clkStep too high, deadlock found: analyse deadlock" << endl;
++ 	      #endif
+                  // Find cause of deadlock
+                  analyzeDeadlock(sp, dep);
+                  return 0;
+***************
+*** 1014,1027 ****
+          // Initialize blocking channels
+          for (uint c = 0; c < g->nrChannels(); c++)
+              d->dep[c] = false;
+! 
+          // Execute the CSDF graph to find its output interval
+          d->thr = transitionSystem->execCSDFgraph(d->sp, d->dep);
+! 
+          //cerr << d->sz << " " << d->thr << endl;
+          //for (uint c = 0; c < g->nrChannels(); c++)
+          //    cerr << d->sp[c] << " " << d->dep[c] << endl;
+          //cerr << endl;
+      }
+  
+      /**
+--- 1225,1277 ----
+          // Initialize blocking channels
+          for (uint c = 0; c < g->nrChannels(); c++)
+              d->dep[c] = false;
+! 	
+          // Execute the CSDF graph to find its output interval
+          d->thr = transitionSystem->execCSDFgraph(d->sp, d->dep);
+! 	
+          //cerr << d->sz << " " << d->thr << endl;
+          //for (uint c = 0; c < g->nrChannels(); c++)
+          //    cerr << d->sp[c] << " " << d->dep[c] << endl;
+          //cerr << endl;
++ 
++ 	#ifdef VERBOSE_OUT
++ 	cout << "\tCurrent StorageDistribution info:" << endl;
++ 	cout << "\tNumber of edges: " << g->nrChannels() << endl;
++ 	cout << "\tChannel quantities:\n\t";
++ 	for (CSDFchannelsIter iter = g->channelsBegin();
++ 	     iter != g->channelsEnd(); iter++) {
++ 	  CSDFchannel *c = *iter;
++ 	  if (c->getSrcActor()->getId() != c->getDstActor()->getId()) { // ignore feedback edges
++ 	    cout << d->sp[c->getId()] << " ";
++ 	  }
++ 	}
++ 	cout << endl;
++ 	cout << "\tDistribution size: " << d->sz << endl;
++ 	cout << "\tThroughput: " << d->thr << endl;
++ 	cout << endl;
++ 	#endif
++ 
++ 	#ifdef LOG_OUT
++ 	// log dse data
++ 	string output("\"");
++ 	string delim("");
++ 	uint noFeedbackSize = 0;	
++ 	for (CSDFchannelsIter iter = g->channelsBegin();
++ 	     iter != g->channelsEnd(); iter++) {
++ 	  CSDFchannel *c = *iter;
++ 	  if (c->getSrcActor()->getId() != c->getDstActor()->getId()) { // ignore feedback edges
++ 	    output += delim;
++ 	    output += to_string(d->sp[c->getId()]);
++ 	    delim = ",";
++ 	    noFeedbackSize += d->sp[c->getId()];
++ 	  }
++ 	}
++ 	output += "\"";
++ 	
++ 	dseLog << noFeedbackSize << "," // distribution size
++ 	       << d->thr << "," // throughput
++ 	       << output << ","; // channel quantities
++ 	#endif
+      }
+  
+      /**
+***************
+*** 1039,1044 ****
+          // throughput with previous (smaller) distribution size
+          if (ds->prev != NULL && ds->prev->thr == ds->thr)
+          {
+              // No minimal storage distributions exist in this list
+              // Iterate over the list of storage distributions
+              d = ds->distributions;
+--- 1289,1298 ----
+          // throughput with previous (smaller) distribution size
+          if (ds->prev != NULL && ds->prev->thr == ds->thr)
+          {
++ 	  #ifdef VERBOSE_OUT
++ 	  cout << "\t\tNew storage distribution set of dist size " << ds->sz
++ 	       << " found to be non-minimal: removing from set" << endl;
++ 	  #endif
+              // No minimal storage distributions exist in this list
+              // Iterate over the list of storage distributions
+              d = ds->distributions;
+***************
+*** 1079,1084 ****
+                      t = d->next;
+  
+                      // Cleanup d
+                      deleteStorageDistribution(d);
+  
+                      // Next
+--- 1333,1342 ----
+                      t = d->next;
+  
+                      // Cleanup d
++ 		    #ifdef VERBOSE_OUT
++ 		    cout << "\t\tStorage distribution of size " << d->sz
++ 			 << " found to be non-minimal: removing from set" << endl;
++ 		    #endif
+                      deleteStorageDistribution(d);
+  
+                      // Next
+***************
+*** 1109,1117 ****
+          StorageDistribution *di;
+          bool equalDistr;
+  
+          // First distribution ever added?
+          if (minStorageDistributions == NULL)
+          {
+              // Create new set of storage distributions
+              dsNew = new StorageDistributionSet;
+              dsNew->sz = d->sz;
+--- 1367,1382 ----
+          StorageDistribution *di;
+          bool equalDistr;
+  
++ 	#ifdef VERBOSE_OUT
++ 	cout << "\t\tAttempting to add storage distribution of dist sz: " << d->sz
++ 	     << " to set" << endl;
++ 	#endif
+          // First distribution ever added?
+          if (minStorageDistributions == NULL)
+          {
++ 	  #ifdef VERBOSE_OUT
++ 	  cout << "\t\t\tFirst of this distribution size: adding new distribution" << endl;
++ 	  #endif
+              // Create new set of storage distributions
+              dsNew = new StorageDistributionSet;
+              dsNew->sz = d->sz;
+***************
+*** 1154,1167 ****
+                  }
+  
+                  // Found equal distribution
+!                 if (equalDistr)
+!                     return false;
+  
+                  // Next
+                  di = di->next;
+              }
+  
+              // Distribution 'd' not yet in the set, so let's add it
+              ds->distributions->prev = d;
+              d->next = ds->distributions;
+              ds->distributions = d;
+--- 1419,1439 ----
+                  }
+  
+                  // Found equal distribution
+!                 if (equalDistr) {
+! 		  #ifdef VERBOSE_OUT
+! 		  cout << "\t\t\tFound matching distribution: not adding new distribution" << endl;
+! 		  #endif
+! 		  return false;
+! 		}
+  
+                  // Next
+                  di = di->next;
+              }
+  
+              // Distribution 'd' not yet in the set, so let's add it
++ 	    #ifdef VERBOSE_OUT
++ 	    cout << "\t\t\tNew storage distribution added!" << endl;
++ 	    #endif
+              ds->distributions->prev = d;
+              d->next = ds->distributions;
+              ds->distributions = d;
+***************
+*** 1169,1175 ****
+          else if (ds->next == NULL)
+          {
+              // No set of distribution in the list with same or larger size?
+! 
+              // Create new set of storage distributions
+              dsNew = new StorageDistributionSet;
+              dsNew->sz = d->sz;
+--- 1441,1449 ----
+          else if (ds->next == NULL)
+          {
+              // No set of distribution in the list with same or larger size?
+! 	  #ifdef VERBOSE_OUT
+! 	  cout << "\t\t\tFirst of this distribution size: adding new distribution" << endl;
+! 	  #endif
+              // Create new set of storage distributions
+              dsNew = new StorageDistributionSet;
+              dsNew->sz = d->sz;
+***************
+*** 1189,1194 ****
+              // distribution 'd'.
+  
+              // Create new set of storage distributions
+              dsNew = new StorageDistributionSet;
+              dsNew->sz = d->sz;
+              dsNew->thr = 0;
+--- 1463,1471 ----
+              // distribution 'd'.
+  
+              // Create new set of storage distributions
++ 	  #ifdef VERBOSE_OUT
++ 	  cout << "\t\t\tFirst of this distribution size: adding new distribution" << endl;
++ 	  #endif
+              dsNew = new StorageDistributionSet;
+              dsNew->sz = d->sz;
+              dsNew->thr = 0;
+***************
+*** 1218,1230 ****
+      {
+          StorageDistribution *dNew;
+  
+          // Compute throughput and storage dependencies
+          execStorageDistribution(d);
+  
+          // Throughput of d larger then current maximum of the set
+          if (d->thr > ds->thr)
+              ds->thr = d->thr;
+  
+          // Create new storage distributions for every channel which
+          // has a storage dependency in d
+          for (uint c = 0; c < g->nrChannels(); c++)
+--- 1495,1524 ----
+      {
+          StorageDistribution *dNew;
+  
++ 	#ifdef LOG_OUT
++ 	auto startTime = std::chrono::steady_clock::now();
++ 	#endif
+          // Compute throughput and storage dependencies
+          execStorageDistribution(d);
++ 	#ifdef LOG_OUT
++ 	auto endTime = std::chrono::steady_clock::now();
++ 	std::chrono::duration<double, milli> execTime = endTime - startTime; // duration of individual execution
++ 	cumulativeTime += execTime;
++ 	#endif
++ 	#ifdef VERBOSE_OUT
++ 	computation_counter++;
++ 	#endif
+  
+          // Throughput of d larger then current maximum of the set
+          if (d->thr > ds->thr)
+              ds->thr = d->thr;
+  
++ 	#ifdef LOG_OUT
++ 	// log execution times (cont. from execStorageDistribution)
++ 	dseLog << execTime.count() << ","
++ 	       << cumulativeTime.count() << endl;
++ 	#endif
++ 
+          // Create new storage distributions for every channel which
+          // has a storage dependency in d
+          for (uint c = 0; c < g->nrChannels(); c++)
+***************
+*** 1232,1241 ****
+              // Channel c has storage dependency?
+              if (d->dep[c])
+              {
+                  // Do not enlarge the channel if its a self-edge
+                  if (g->getChannel(c)->getSrcActor()->getId()
+!                     == g->getChannel(c)->getDstActor()->getId())
+!                     continue;
+  
+                  // Create new storage distribution with channel c enlarged
+                  dNew = newStorageDistribution();
+--- 1526,1542 ----
+              // Channel c has storage dependency?
+              if (d->dep[c])
+              {
++ 	      #ifdef VERBOSE_OUT
++ 	      cout << "\tFound storage dependency in channel " << g->getChannel(c)->getName() << endl;
++ 	      #endif
+                  // Do not enlarge the channel if its a self-edge
+                  if (g->getChannel(c)->getSrcActor()->getId()
+!                     == g->getChannel(c)->getDstActor()->getId()) {
+! 		  #ifdef VERBOSE_OUT
+! 		  cout << "\t\tChannel " << g->getChannel(c)->getName() << " is a self-edge: ignoring" << endl;
+! 		  #endif
+! 		  continue;
+! 		}
+  
+                  // Create new storage distribution with channel c enlarged
+                  dNew = newStorageDistribution();
+***************
+*** 1244,1256 ****
+                  for (uint i = 0; i < g->nrChannels(); i++)
+                  {
+                      dNew->sp[i] = d->sp[i];
+!                     if (i == c)
+!                         dNew->sp[i] += minSzStep[c];
+                  }
+                  dNew->next = NULL;
+                  dNew->prev = NULL;
+  
+                  // Add storage distribution to set of distributions to be checked
+                  if (!addStorageDistributionToChecklist(dNew))
+                  {
+                      // Distribution already in check list
+--- 1545,1565 ----
+                  for (uint i = 0; i < g->nrChannels(); i++)
+                  {
+                      dNew->sp[i] = d->sp[i];
+!                     if (i == c) {
+! 		      dNew->sp[i] += minSzStep[c];
+! 		      #ifdef VERBOSE_OUT
+! 		      cout << "\t\tIncreasing channel size of " << g->getChannel(c)->getName()
+! 			   << " to " << dNew->sp[i] << endl;
+! 		      #endif
+! 		    }
+                  }
+                  dNew->next = NULL;
+                  dNew->prev = NULL;
+  
+                  // Add storage distribution to set of distributions to be checked
++ 		#ifdef VERBOSE_OUT
++ 		cout << "\tUpdating checklist with new storage distribution..." << endl;
++ 		#endif
+                  if (!addStorageDistributionToChecklist(dNew))
+                  {
+                      // Distribution already in check list
+***************
+*** 1274,1279 ****
+          d = ds->distributions;
+          while (d != NULL)
+          {
+              // Explore distribution d
+              exploreStorageDistribution(ds, d);
+  
+--- 1583,1591 ----
+          d = ds->distributions;
+          while (d != NULL)
+          {
++ 	  #ifdef VERBOSE_OUT
++ 	  cout << "\nExploring new storage distribution:" << endl;
++ 	  #endif
+              // Explore distribution d
+              exploreStorageDistribution(ds, d);
+  
+***************
+*** 1282,1287 ****
+          }
+  
+          // Remove all non-minimal storage distributions from the set
+          minimizeStorageDistributionsSet(ds);
+      }
+  
+--- 1594,1603 ----
+          }
+  
+          // Remove all non-minimal storage distributions from the set
++ 	#ifdef VERBOSE_OUT
++ 	cout << "\tTrying to minimise set with distribution size: "
++ 	     << ds->sz << endl;
++ 	#endif
+          minimizeStorageDistributionsSet(ds);
+      }
+  
+***************
+*** 1312,1317 ****
+          // Check sets of storage distributions till no distributions left to check,
+          // or throughput bound exceeded, or maximal throughput reached
+          ds = minStorageDistributions;
+          while (ds != NULL)
+          {
+              // Explore all distributions with size 'ds->sz'
+--- 1628,1644 ----
+          // Check sets of storage distributions till no distributions left to check,
+          // or throughput bound exceeded, or maximal throughput reached
+          ds = minStorageDistributions;
++ 
++ 	// Initialise log file
++ 	#ifdef LOG_OUT
++ 	dseLog.open(dirName + logDirName + g->getName() + "_dselog_sdf3.csv");
++ 	dseLog << "storage distribution size,throughput,channel quantities,computation duration,cumulative duration"
++ 	       << endl; // initialise headers
++ 	#endif
++ 
++ 	#ifdef VERBOSE_OUT
++ 	cout << "DSE BEGIN:" << endl;
++ 	#endif
+          while (ds != NULL)
+          {
+              // Explore all distributions with size 'ds->sz'
+***************
+*** 1397,1402 ****
+              for (uint c = 0; c < g->nrChannels(); c++)
+                  minStorageDistributions->distributions->sp[c] = 0;
+          }
+      }
+  
+      /**
+--- 1724,1800 ----
+              for (uint c = 0; c < g->nrChannels(); c++)
+                  minStorageDistributions->distributions->sp[c] = 0;
+          }
++ 
++ 	// close log file
++ 	#ifdef LOG_OUT
++ 	dseLog.close();
++ 	#endif
++ 	
++ 	// print DSE results
++ 	#ifdef VERBOSE_OUT
++ 	long int pp_counter = 0;
++ 	cout << "\nDSE RESULTS [START] (target throughput: " << maxThroughput
++ 	     << "):" << endl;
++ 
++ 	for (StorageDistributionSet *p = minStorageDistributions; p != NULL;
++ 	     p = p->next) {
++ 	  cout << "Printing storage distributions of distribution size: "
++ 	       << p->sz << endl;
++ 	  for (StorageDistribution *d = p->distributions; d != NULL;
++ 	       d = d->next) {
++ 	    pp_counter++;
++ 	    cout << "\tCurrent StorageDistribution info:" << endl;
++ 	    cout << "\tNumber of edges: " << g->nrChannels() << endl;
++ 	    cout << "\tChannel quantities:\n\t";
++ 	    for (uint c = 0; c < g->nrChannels(); c++) {
++ 	      if (g->getChannel(c)->getSrcActor()->getId() !=
++ 		  g->getChannel(c)->getDstActor()->getId()) {
++ 		cout << d->sp[g->getChannel(c)->getId()] << " ";
++ 	      }
++ 	    }
++ 	    cout << endl;
++ 	    cout << "\tDistribution size: " << d->sz << endl;
++ 	    cout << "\tThroughput: " << d->thr << endl;
++ 	  }
++ 	}
++ 	cout << "DSE RESULTS [END]" << endl;
++ 	cout << "Done with search!" << endl;
++ 	cout << "Number of computations: " << computation_counter << endl;
++ 	cout << "Number of pareto points: " << pp_counter << endl;
++ 	#endif
++ 
++ 	#ifdef LOG_OUT
++ 	// Variables for pareto point logging
++ 	ofstream ppLog;
++ 	ppLog.open(dirName + ppDirName + g->getName() + "_pp_sdf3.csv");
++ 	// Initialise log file
++ 	ppLog << "storage distribution size,throughput,channel quantities" << endl;
++ 	
++ 	for (StorageDistributionSet *p = minStorageDistributions; p != NULL;
++ 	     p = p->next) {
++ 	  for (StorageDistribution *d = p->distributions; d != NULL;
++ 	       d = d->next) {
++ 	    string output("\"");
++ 	    string delim("");
++ 	    uint noFeedbackSize = 0;
++ 	    for (uint c = 0; c < g->nrChannels(); c++) {
++ 	      if (g->getChannel(c)->getSrcActor()->getId() !=
++ 		  g->getChannel(c)->getDstActor()->getId()) {
++ 		output += delim;
++ 		output += to_string(d->sp[g->getChannel(c)->getId()]);
++ 		delim = ",";
++ 		noFeedbackSize += d->sp[g->getChannel(c)->getId()];
++ 	      }
++ 	    }
++ 	    output += "\"";
++ 	    ppLog << noFeedbackSize << ","
++ 		  << d->thr << ","
++ 		  << output << endl;
++ 	  }
++ 	}
++ 	ppLog.close();
++ 	#endif
++ 
+      }
+  
+      /**
+***************
+*** 1416,1421 ****
+          minStorageDistributions = NULL;
+  
+          // Initialize bounds on the search space
+          initBoundsSearchSpace(g);
+  
+          // Create a transition system
+--- 1814,1822 ----
+          minStorageDistributions = NULL;
+  
+          // Initialize bounds on the search space
++         #ifdef VERBOSE_OUT
++ 	cout << "INITIALISING SEARCH PARAMETERS:" << endl;
++         #endif
+          initBoundsSearchSpace(g);
+  
+          // Create a transition system
+*** selftimed_throughput.cc	2014-07-24 12:16:04.000000000 +0800
+--- selftimed_throughput.cc	2021-01-22 14:11:41.872482013 +0800
+***************
+*** 38,44
+  
+  namespace CSDF
+  {
+!     //#define _PRINT_STATESPACE
+  
+      /******************************************************************************
+       * State
+--- 38,44 -----
+  
+  namespace CSDF
+  {
+!   //#define _PRINT_STATESPACE
+  
+      /******************************************************************************
+       * State
+***************
+*** 239,245
+              // Time between previous state
+              time += s.glbClk;
+          }
+! 
+          return (TDtime)(nr_fire) / (time);
+      }
+  
+--- 239,246 -----
+              // Time between previous state
+              time += s.glbClk;
+          }
+!         // cout << "total number execs: " << nr_fire
+!         //      << " total time: " << time << endl;
+          return (TDtime)(nr_fire) / (time);
+      }
+  
+***************
+*** 523,529
+                          if (repCnt == outputActorRepCnt)
+                          {
+  #ifdef _PRINT_STATESPACE
+!                             printState(currentState, cout);
+  #endif
+                              // Add state to hash of visited states
+                              if (!storeState(currentState, recurrentState))
+--- 524,530 -----
+                          if (repCnt == outputActorRepCnt)
+                          {
+  #ifdef _PRINT_STATESPACE
+!                             currentState.print(cout);
+  #endif
+                              // Add state to hash of visited states
+                              if (!storeState(currentState, recurrentState))
+*** buffer.cc	2014-07-24 12:16:04.000000000 +0800
+--- buffer.cc	2021-01-21 15:28:09.061685107 +0800
+***************
+*** 38,46 ****
+  #include "buffer.h"
+  #include "../../base/algo/repetition_vector.h"
+  #include "../throughput/throughput.h"
+! 
+  namespace SDF
+  {
+      /******************************************************************************
+       * Bounds on the search space
+       *****************************************************************************/
+--- 38,57 ----
+  #include "buffer.h"
+  #include "../../base/algo/repetition_vector.h"
+  #include "../throughput/throughput.h"
+! // libraries for data logging
+! #include <chrono>
+! #include <string>
+! #define LOG_OUT // log data of DSE in CSVs
+  namespace SDF
+  {
++   // variables for data logging
++ #ifdef LOG_OUT
++   std::string dirName = std::getenv("SDF3LOGDIR");
++   std::string logDirName = "dse_logs/";
++   std::string ppDirName = "pp_logs/";
++   ofstream dseLog; // save search path data in DSE log
++   std::chrono::duration<double, std::milli> cumulativeTime;
++ #endif
+      /******************************************************************************
+       * Bounds on the search space
+       *****************************************************************************/
+***************
+*** 957,962 ****
+          //for (uint c = 0; c < g->nrChannels(); c++)
+          //    cerr << d->sp[c] << " " << d->dep[c] << endl;
+          //cerr << endl;
+      }
+  
+      /**
+--- 968,994 ----
+          //for (uint c = 0; c < g->nrChannels(); c++)
+          //    cerr << d->sp[c] << " " << d->dep[c] << endl;
+          //cerr << endl;
++ #ifdef LOG_OUT
++ 	// log dse data
++ 	std::string output("\"");
++ 	std::string delim("");
++ 	uint noFeedbackSize = 0;
++ 	for (SDFchannelsIter iter = g->channelsBegin();
++ 	     iter != g->channelsEnd(); iter++) {
++ 	  SDFchannel *c = *iter;
++ 	  if (c->getSrcActor()->getId() != c->getDstActor()->getId()) { // ignore feedback edges
++ 	    output += delim;
++ 	    output += std::to_string(d->sp[c->getId()]);
++ 	    delim = ",";
++ 	    noFeedbackSize += d->sp[c->getId()];
++ 	  }
++ 	}
++ 	output += "\"";
++ 
++ 	dseLog << noFeedbackSize << "," // distribution size
++ 	       << d->thr << "," // throughput
++ 	       << output << ","; // channel quantities
++ #endif
+      }
+  
+      /**
+***************
+*** 1152,1165 ****
+          StorageDistributionSet *ds, StorageDistribution *d)
+      {
+          StorageDistribution *dNew;
+! 
+          // Compute throughput and storage dependencies
+          execStorageDistribution(d);
+  
+          // Throughput of d larger then current maximum of the set
+          if (d->thr > ds->thr)
+              ds->thr = d->thr;
+  
+          // Create new storage distributions for every channel which
+          // has a storage dependency in d
+          for (uint c = 0; c < g->nrChannels(); c++)
+--- 1184,1210 ----
+          StorageDistributionSet *ds, StorageDistribution *d)
+      {
+          StorageDistribution *dNew;
+! #ifdef LOG_OUT
+! 	auto startTime = std::chrono::steady_clock::now();
+! #endif
+          // Compute throughput and storage dependencies
+          execStorageDistribution(d);
++ #ifdef LOG_OUT
++ 	auto endTime = std::chrono::steady_clock::now();
++ 	std::chrono::duration<double, std::milli> execTime = endTime - startTime; // duration of individual execution
++ 	cumulativeTime += execTime;
++ #endif
+  
+          // Throughput of d larger then current maximum of the set
+          if (d->thr > ds->thr)
+              ds->thr = d->thr;
+  
++ #ifdef LOG_OUT
++ 	// log execution times (cont. from execStorageDistribution)
++ 	dseLog << execTime.count() << ","
++ 	       << cumulativeTime.count() << endl;
++ #endif
++ 
+          // Create new storage distributions for every channel which
+          // has a storage dependency in d
+          for (uint c = 0; c < g->nrChannels(); c++)
+***************
+*** 1247,1252 ****
+          // Check sets of storage distributions till no distributions left to check,
+          // or throughput bound exceeded, or maximal throughput reached
+          ds = minStorageDistributions;
+          while (ds != NULL)
+          {
+              // Explore all distributions with size 'ds->sz'
+--- 1292,1303 ----
+          // Check sets of storage distributions till no distributions left to check,
+          // or throughput bound exceeded, or maximal throughput reached
+          ds = minStorageDistributions;
++         // Initialise log file
++ #ifdef LOG_OUT
++ 	dseLog.open(dirName + logDirName + g->getName() + "_dselog_sdf3.csv");
++ 	dseLog << "storage distribution size,throughput,channel quantities,computation duration,cumulative duration"
++ 	       << endl; // initialise headers
++ #endif
+          while (ds != NULL)
+          {
+              // Explore all distributions with size 'ds->sz'
+***************
+*** 1332,1337 ****
+              for (uint c = 0; c < g->nrChannels(); c++)
+                  minStorageDistributions->distributions->sp[c] = 0;
+          }
+      }
+  
+      /**
+--- 1383,1421 ----
+              for (uint c = 0; c < g->nrChannels(); c++)
+                  minStorageDistributions->distributions->sp[c] = 0;
+          }
++         // close log file
++ #ifdef LOG_OUT
++ 	dseLog.close();
++ 	// Variables for pareto point logging
++ 	ofstream ppLog;
++ 	ppLog.open(dirName + ppDirName + g->getName() + "_pp_sdf3.csv");
++ 	// Initialise log file
++ 	ppLog << "storage distribution size,throughput,channel quantities" << endl;
++ 
++ 	for (StorageDistributionSet *p = minStorageDistributions; p != NULL;
++ 	     p = p->next) {
++ 	  for (StorageDistribution *d = p->distributions; d != NULL;
++ 	       d = d->next) {
++ 	    std::string output("\"");
++ 	    std::string delim("");
++ 	    uint noFeedbackSize = 0;
++ 	    for (uint c = 0; c < g->nrChannels(); c++) {
++ 	      if (g->getChannel(c)->getSrcActor()->getId() !=
++ 		  g->getChannel(c)->getDstActor()->getId()) {
++ 		output += delim;
++ 		output += std::to_string(d->sp[g->getChannel(c)->getId()]);
++ 		delim = ",";
++ 		noFeedbackSize += d->sp[g->getChannel(c)->getId()];
++ 	      }
++ 	    }
++ 	    output += "\"";
++ 	    ppLog << noFeedbackSize << ","
++ 		  << d->thr << ","
++ 		  << output << endl;
++ 	  }
++ 	}
++ 	ppLog.close();
++ #endif
+      }
+  
+      /**
diff -ruN sdf3_140724/sdf3/sdf/analysis/buffersizing/buffer.cc sdf3_custom/sdf3/sdf/analysis/buffersizing/buffer.cc
--- sdf3_140724/sdf3/sdf/analysis/buffersizing/buffer.cc	2014-07-24 12:16:04.000000000 +0800
+++ sdf3_custom/sdf3/sdf/analysis/buffersizing/buffer.cc	2022-07-12 16:37:08.059591806 +0800
@@ -38,9 +38,25 @@
 #include "buffer.h"
 #include "../../base/algo/repetition_vector.h"
 #include "../throughput/throughput.h"
-
+#include <stack>
+// libraries for data logging
+#include <chrono>
+#include <string>
+#define LOG_OUT // log data of DSE in CSVs
 namespace SDF
 {
+  bool useSCCStorageDeps = !strcmp(std::getenv("USE_SCC"), "true"); // TODO fix this workaround to not rely on keyword
+  bool useCoarse = !strcmp(std::getenv("COARSE"), "true"); // TODO fix this workaround to not rely on keyword
+  int coarseMultiplier = 2;
+  // variables for data logging
+#ifdef LOG_OUT
+  std::string dirName = std::getenv("SDF3LOGDIR");
+  std::string logDirName = "dse_logs/";
+  std::string ppDirName = "pp_logs/";
+  ofstream dseLog; // save search path data in DSE log
+  std::chrono::duration<double, std::milli> cumulativeTime;
+  std::chrono::steady_clock::time_point cumulativeStart;
+#endif
     /******************************************************************************
      * Bounds on the search space
      *****************************************************************************/
@@ -63,6 +79,9 @@
      */
     void SDFstateSpaceBufferAnalysis::initMinimalChannelSzStep(TimedSDFgraph *g)
     {
+      #ifdef VERBOSE_OUT
+      cout << "Calculating minimal channel step sizes..." << endl;
+      #endif
         minSzStep = new TBufSize [g->nrChannels()];
 
         for (SDFchannelsIter iter = g->channelsBegin(); iter != g->channelsEnd();
@@ -78,6 +97,10 @@
             minStepSz = gcd(p, c);
 
             minSzStep[ch->getId()] = minStepSz;
+            #ifdef VERBOSE_OUT
+            cout << "Min. step size for channel " << ch->getName() << ": "
+                 << minStepSz << endl;
+            #endif
         }
     }
 
@@ -87,6 +110,9 @@
      */
     void SDFstateSpaceBufferAnalysis::initMinimalChannelSz(TimedSDFgraph *g)
     {
+      #ifdef VERBOSE_OUT
+      cout << "Calculating minimal channel sizes (for positive throughput)..." << endl;
+      #endif
         minSz =  new TBufSize [g->nrChannels()];
 
         for (SDFchannelsIter iter = g->channelsBegin(); iter != g->channelsEnd();
@@ -245,6 +271,10 @@
                 a = *iter;
                 min = repVec[a->getId()];
             }
+            #ifdef VERBOSE_OUT
+            cout << "Minimum channel size for " << ch->getName() << ": "
+                 << minSz[ch->getId()] << endl;
+            #endif
         }
 
         // Set output actor and its repetition vector count
@@ -309,7 +339,12 @@
             // Time between previous state
             time += s.glbClk;
         }
-
+        #ifdef DEPS_OUT
+        cout << "\nComputing throughput..."
+             << "\nNumber of executions: " << nr_fire
+             << "\nPeriod length: " << time
+             << endl;
+        #endif
         return (TDtime)(nr_fire) / (time);
     }
 
@@ -341,6 +376,10 @@
                 if (color[b] == 1)
                 {
                     // Found a cycle in the graph containing node b
+                  #ifdef DEPS_OUT
+                  cout << "\t\t\t\t Found cycle in abstract dep graph containing node from actor "
+                       << g->getActor(a)->getName() << " and actor " << g->getActor(b)->getName() << endl;
+                  #endif
                     c = a;
                     d = b;
                     do
@@ -355,7 +394,12 @@
                             CId dstId = ch->getDstActor()->getId();
 
                             if (dstId == d && srcId == c)
+                              {
+                                #ifdef DEPS_OUT
+                                cout << "\t\t\t\t  Storage dependency found in channel " << ch->getName() << endl;
+                                #endif
                                 dep[ch->getId()] = true;
+                              }
                         }
 
                         // Next
@@ -418,6 +462,122 @@
         delete [] pi;
     }
 
+    /**
+     * findStorageDependenciesSCC ()
+     * The function find all cycles in the abstract dependency graph using
+     * strongly-connected components
+     */
+    void SDFstateSpaceBufferAnalysis::TransitionSystem
+    ::findStorageDependenciesSCC(bool **abstractDepGraph, bool *dep)
+    {
+        int *visited;
+        std::stack<int> dfsOrder;
+        std::vector<int> sccNodes;
+        int sccCount = 1;
+        std::map<int, std::vector<int>> sccMap;
+
+        // Initialize DFS data structures
+        visited = new int [g->nrActors()];
+        for (uint i = 0; i < g->nrActors(); i++)
+            visited[i] = 0;
+
+        // Initialize storage dependencies
+        for (uint c = 0; c < g->nrChannels(); c++)
+            dep[c] = false;
+
+        // DFS from every node in the graph to find all cycles
+        for (uint i = 0; i < g->nrActors(); i++)
+        {
+          if (!visited[i]) {
+            // compute dfs stack
+            computeDFSStack(i, visited, abstractDepGraph, dfsOrder);
+          }
+        }
+
+        // reset visited node list
+        for (uint i = 0; i < g->nrActors(); i++) {
+          visited[i] = 0;
+        }
+
+        // perform transpose dfs according to dfs stack
+        while (!dfsOrder.empty())
+          {
+            int firstId = dfsOrder.top();
+            dfsOrder.pop();
+            if (!visited[firstId])
+              {
+                dfsTranspose(firstId, visited, abstractDepGraph, sccNodes);
+                sccMap[sccCount] = sccNodes;
+                sccCount++;
+                sccNodes.clear();
+              }
+          }
+
+        // look for actors in the same SCC --- channel connecting them will have storage dep
+        for (SDFchannelsIter iter = g->channelsBegin();
+             iter != g->channelsEnd(); iter++)
+          {
+            SDFchannel *ch = *iter;
+            CId srcId = ch->getSrcActor()->getId();
+            CId dstId = ch->getDstActor()->getId();
+
+            if (abstractDepGraph[srcId][dstId])
+              {
+                for (auto const& component : sccMap)
+                  {
+                    bool srcActorInSCC = std::find(component.second.begin(),
+                                                   component.second.end(), srcId) != component.second.end();
+                    bool dstActorInSCC = std::find(component.second.begin(),
+                                                   component.second.end(), dstId) != component.second.end();
+                    if (srcActorInSCC && dstActorInSCC)
+                      {
+                        dep[ch->getId()] = true;
+                      }
+                  }
+              }
+          }
+
+        // Cleanup
+        delete [] visited;
+    }
+
+  void SDFstateSpaceBufferAnalysis::TransitionSystem
+  ::computeDFSStack(uint startId, int *visited, bool **abstractDepGraph,
+                    std::stack<int> &dfsOrder)
+  {
+    if (visited[startId]) {
+      return;
+    }
+    visited[startId] = 1;
+    for (uint adjId = 0; adjId < g->nrActors(); adjId++)
+      {
+        if (abstractDepGraph[startId][adjId])
+          {
+            computeDFSStack(adjId, visited, abstractDepGraph, dfsOrder);
+          }
+      }
+    dfsOrder.push(startId);
+  }
+
+  void SDFstateSpaceBufferAnalysis::TransitionSystem
+  ::dfsTranspose(uint startId, int *visited, bool **abstractDepGraph,
+                 std::vector<int> &sccNodes)
+  {
+    if (visited[startId]) {
+      return;
+    }
+    visited[startId] = 1;
+    sccNodes.push_back(startId);
+
+    for (uint adjId = 0; adjId < g->nrActors(); adjId++)
+      {
+        if (abstractDepGraph[adjId][startId])
+          {
+            dfsTranspose(adjId, visited, abstractDepGraph, sccNodes);
+          }
+      }
+  }
+
     /******************************************************************************
      * SDF
      *****************************************************************************/
@@ -477,6 +637,9 @@
     void SDFstateSpaceBufferAnalysis::TransitionSystem::startActorFiring(
         TimedSDFactor *a)
     {
+      #ifdef DEPS_OUT
+      cout << "Start firing of actor " << a->getName() << endl;
+      #endif
         // Consume tokens from inputs and space for output tokens
         for (SDFportsIter iter = a->portsBegin(); iter != a->portsEnd(); iter++)
         {
@@ -614,6 +777,17 @@
                 // Not enough tokens in the previous state?
                 if (!CH_TOKENS_PREV(c->getId(), p->getRate()))
                 {
+                  #ifdef DEPS_OUT
+                  cout << "\t\t\t\tFound causal dependency in channel " << c->getName()
+                       << ": not enough tokens in previous state (needed at least "
+                       << p->getRate()[ACT_SEQ_POS(a->getId())] << " tokens)" << endl;
+                  cout << "Previous state:" << endl;
+                  previousState.print(cout);
+                  cout << endl;
+                  cout << "Current state:" << endl;
+                  currentState.print(cout);
+                  cout << endl;
+                  #endif
                     abstractDepGraph[dstActor->getId()][srcActor->getId()] = true;
                 }
             }
@@ -622,6 +796,17 @@
                 // Not enough space in the previous state?
                 if (!CH_SPACE_PREV(c->getId(), p->getRate()))
                 {
+                  #ifdef DEPS_OUT
+                  cout << "\t\t\t\tFound causal dependency in channel " << c->getName()
+                       << ": not enough space in previous state (needed at least "
+                       << p->getRate()[ACT_SEQ_POS(a->getId())] << " space)" << endl;
+                  cout << "Previous state:" << endl;
+                  previousState.print(cout);
+                  cout << endl;
+                  cout << "Current state:" << endl;
+                  currentState.print(cout);
+                  cout << endl;
+                  #endif
                     abstractDepGraph[srcActor->getId()][dstActor->getId()] = true;
                 }
             }
@@ -693,6 +878,10 @@
                 // Ready to fire actor a?
                 while (actorReadyToFire(a))
                 {
+                  #ifdef DEPS_OUT
+                  cout << "\n\t\t\tActor " << a->getName() << " ready to fire" << endl;
+                  cout << "\t\t\tFind causal dependencies for this actor" << endl;
+                  #endif
                     // Track causal dependencies on firing of actor a
                     findCausalDependencies(a, abstractDepGraph);
 
@@ -704,6 +893,9 @@
             // Clock step
             clockStep();
 
+            #ifdef DEPS_OUT
+            cout << "\t\t\tStoring partial state by setting current state ch and sp to prev state" << endl;
+            #endif
             // Store partial state to check for progress
             for (uint i = 0; i < g->nrChannels(); i++)
             {
@@ -719,17 +911,35 @@
 
                 while (actorReadyToEnd(a))
                 {
+                  #ifdef DEPS_OUT
+                  cout << "\n\t\t\tActor " << a->getName() << " ready to end...." << endl;
+                  #endif
                     if (outputActor->getId() == a->getId())
                     {
                         repCnt++;
+                        #ifdef DEPS_OUT
+                        cout << "\t\t\tActor is output actor (has lowest rep vector value): incrementing repCnt to: "
+                             << repCnt << endl;
+                        #endif
                         if (repCnt == outputActorRepCnt)
                         {
+                          #ifdef DEPS_OUT
+                          cout << "\t\t\trepCnt equal to outputActorRepCnt:" << endl;
+                          #endif
                             // Found periodic state
                             if (currentState == periodicState)
                             {
+                              #ifdef DEPS_OUT
+                              cout << "\t\t\tCurrent state is the periodic state" << endl;
+                              cout << "\t\t\t\tLook for storage dependencies (cycles in abstract dependency graph)" << endl;
+                              #endif
                                 // Cycles in the dependency graph indicate storage
                                 // dependencies
+                              if (useSCCStorageDeps) {
+                                findStorageDependenciesSCC(abstractDepGraph, dep);
+                              } else {
                                 findStorageDependencies(abstractDepGraph, dep);
+                              }
 
                                 // Cleanup
                                 for (uint i = 0; i < g->nrActors(); i++)
@@ -739,6 +949,9 @@
                                 // Done
                                 return;
                             }
+                            #ifdef DEPS_OUT
+                            cout << "Reset currentState.glbClk and repCnt to 0" << endl;
+                            #endif
                             currentState.glbClk = 0;
                             repCnt = 0;
                         }
@@ -768,6 +981,9 @@
             for (uint j = 0; j < g->nrActors(); j++)
                 abstractDepGraph[i][j] = false;
         }
+        #ifdef DEPS_OUT
+        cout << "\tAbstract dependency graph initialised" << endl;
+        #endif
 
         // Check number of tokens on every channel in the graph
         for (SDFchannelsIter iter = g->channelsBegin();
@@ -780,18 +996,34 @@
             // Insufficient tokens to fire destination actor
             if (!CH_TOKENS(c->getId(), c->getDstPort()->getRate()))
             {
+              #ifdef DEPS_OUT
+              cout << "\t\tFound causal dependency in channel " << c->getName()
+                   << ": not enough tokens to fire destination actor " << dstActor->getName()
+                   << " (needed at least " << c->getDstPort()->getRate()[ACT_SEQ_POS(dstActor->getId())]
+                   << " tokens)" << endl;
+              #endif
                 abstractDepGraph[dstActor->getId()][srcActor->getId()] = true;
             }
 
             // Insufficient space to fire source actor
             if (!CH_SPACE(c->getId(), c->getSrcPort()->getRate()))
             {
+              #ifdef DEPS_OUT
+              cout << "\t\tFound causal dependency in channel " << c->getName()
+                   << ": not enough space to fire source actor " << srcActor->getName()
+                   << " (needed at least " << c->getSrcPort()->getRate()[ACT_SEQ_POS(dstActor->getId())]
+                   << " space)" << endl;
+              #endif
                 abstractDepGraph[srcActor->getId()][dstActor->getId()] = true;
             }
         }
 
         // Cycles in the dependency graph indicate storage dependencies
-        findStorageDependencies(abstractDepGraph, dep);
+        if (useSCCStorageDeps) {
+          findStorageDependenciesSCC(abstractDepGraph, dep);
+        } else {
+          findStorageDependencies(abstractDepGraph, dep);
+        }
 
         // Cleanup
         for (uint i = 0; i < g->nrActors(); i++)
@@ -815,6 +1047,10 @@
         clearStoredStates();
 
         // Create initial state
+        #ifdef DEPS_OUT
+        cout << "Initialising previous and current states with " << std::to_string(g->nrActors())
+             << " actors and " << std::to_string(g->nrChannels()) << " channels" << endl;
+        #endif
         currentState.init(g->nrActors(), g->nrChannels());
         currentState.clear();
         previousState.init(g->nrActors(), g->nrChannels());
@@ -833,11 +1069,22 @@
                 return 0;
             }
 
+            #ifdef DEPS_OUT
+            cout << "Setting initial tokens and space for channel: " << c->getName() << " ("
+                 << c->getInitialTokens() << ", " << sp[c->getId()] - c->getInitialTokens()
+                 << ")" << endl;
+            #endif
             CH(c->getId()) = c->getInitialTokens();
             SP(c->getId()) = sp[c->getId()] - c->getInitialTokens();
+            #ifdef DEPS_OUT
+            c->print(cout);
+            #endif
         }
 
         // Fire the actors
+        #ifdef DEPS_OUT
+        cout << "\nBegin actor firings" << endl;
+        #endif
         while (true)
         {
             // Store partial state to check for progress
@@ -855,15 +1102,28 @@
 
                 while (actorReadyToEnd(a))
                 {
+                  #ifdef DEPS_OUT
+                  cout << "\nActor " << a->getName() << " ready to end...." << endl;
+                  #endif
                     if (outputActor->getId() == a->getId())
                     {
                         repCnt++;
+                        #ifdef DEPS_OUT
+                        cout << "\tActor is output actor (has lowest rep vector value): incrementing repCnt to: "
+                             << repCnt << endl;
+                        #endif
                         if (repCnt == outputActorRepCnt)
                         {
+                          #ifdef DEPS_OUT
+                          cout << "\t\trepCnt equal to outputActorRepCnt" << endl;
+                          #endif
                             // Add state to hash of visited states
                             if (!storeState(currentState, recurrentState))
                             {
-                                // Find storage dependencies in periodic phase
+                              // Find storage dependencies in periodic phase
+                              #ifdef DEPS_OUT
+                              cout << "\t\tCurrent state has been visited before: analyse periodic phase" << endl;
+                              #endif
                                 analyzePeriodicPhase(sp, dep);
 
                                 return computeThroughput(recurrentState);
@@ -887,6 +1147,9 @@
                 // Ready to fire actor a?
                 while (actorReadyToFire(a))
                 {
+                  #ifdef DEPS_OUT
+                  cout << "\nActor " << a->getName() << " ready to fire" << endl;
+                  #endif
                     // Fire actor a
                     startActorFiring(a);
                 }
@@ -894,10 +1157,16 @@
 
             // Clock step
             clkStep = clockStep();
+            #ifdef DEPS_OUT
+            cout << "clkStep set to " << clkStep << endl;
+            #endif
 
             // Deadlocked?
             if (clkStep == UINT_MAX)
             {
+              #ifdef DEPS_OUT
+              cout << "clkStep too high, deadlock found: analyse deadlock" << endl;
+              #endif
                 // Find cause of deadlock
                 analyzeDeadlock(sp, dep);
                 return 0;
@@ -957,6 +1226,28 @@
         //for (uint c = 0; c < g->nrChannels(); c++)
         //    cerr << d->sp[c] << " " << d->dep[c] << endl;
         //cerr << endl;
+#ifdef LOG_OUT
+        // log dse data
+        std::string output("\"");
+        std::string delim("");
+        std::string colDelim(";");
+        uint noFeedbackSize = 0;
+        for (SDFchannelsIter iter = g->channelsBegin();
+             iter != g->channelsEnd(); iter++) {
+          SDFchannel *c = *iter;
+          if (c->getSrcActor()->getId() != c->getDstActor()->getId()) { // ignore feedback edges
+            output += delim;
+            output += std::to_string(d->sp[c->getId()]);
+            delim = ",";
+            noFeedbackSize += d->sp[c->getId()];
+          }
+        }
+        output += "\"";
+
+        dseLog << noFeedbackSize << colDelim // distribution size
+               << d->thr << colDelim // throughput
+               << output << colDelim; // channel quantities
+#endif
     }
 
     /**
@@ -974,6 +1265,10 @@
         // throughput with previous (smaller) distribution size
         if (ds->prev != NULL && ds->prev->thr == ds->thr)
         {
+          #ifdef VERBOSE_OUT
+          cout << "\t\tNew storage distribution set of dist size " << ds->sz
+               << " found to be non-minimal: removing from set" << endl;
+          #endif
             // No minimal storage distributions exist in this list
             // Iterate over the list of storage distributions
             d = ds->distributions;
@@ -1014,6 +1309,10 @@
                     t = d->next;
 
                     // Cleanup d
+                    #ifdef VERBOSE_OUT
+                    cout << "\t\tStorage distribution of size " << d->sz
+                         << " found to be non-minimal: removing from set" << endl;
+                    #endif
                     deleteStorageDistribution(d);
 
                     // Next
@@ -1044,9 +1343,16 @@
         StorageDistribution *di;
         bool equalDistr;
 
+        #ifdef VERBOSE_OUT
+        cout << "\t\tAttempting to add storage distribution of dist sz: " << d->sz
+             << " to set" << endl;
+        #endif
         // First distribution ever added?
         if (minStorageDistributions == NULL)
         {
+          #ifdef VERBOSE_OUT
+          cout << "\t\t\tFirst of this distribution size: adding new distribution" << endl;
+          #endif
             // Create new set of storage distributions
             dsNew = new StorageDistributionSet;
             dsNew->sz = d->sz;
@@ -1089,14 +1395,21 @@
                 }
 
                 // Found equal distribution
-                if (equalDistr)
-                    return false;
+                if (equalDistr) {
+                  #ifdef VERBOSE_OUT
+                  cout << "\t\t\tFound matching distribution: not adding new distribution" << endl;
+                  #endif
+                  return false;
+                }
 
                 // Next
                 di = di->next;
             }
 
             // Distribution 'd' not yet in the set, so let's add it
+            #ifdef VERBOSE_OUT
+            cout << "\t\t\tNew storage distribution added!" << endl;
+            #endif
             ds->distributions->prev = d;
             d->next = ds->distributions;
             ds->distributions = d;
@@ -1104,7 +1417,9 @@
         else if (ds->next == NULL)
         {
             // No set of distribution in the list with same or larger size?
-
+          #ifdef VERBOSE_OUT
+          cout << "\t\t\tFirst of this distribution size: adding new distribution" << endl;
+          #endif
             // Create new set of storage distributions
             dsNew = new StorageDistributionSet;
             dsNew->sz = d->sz;
@@ -1124,6 +1439,9 @@
             // distribution 'd'.
 
             // Create new set of storage distributions
+          #ifdef VERBOSE_OUT
+          cout << "\t\t\tFirst of this distribution size: adding new distribution" << endl;
+          #endif
             dsNew = new StorageDistributionSet;
             dsNew->sz = d->sz;
             dsNew->thr = 0;
@@ -1153,13 +1471,28 @@
     {
         StorageDistribution *dNew;
 
+        #ifdef LOG_OUT
+        auto startTime = std::chrono::steady_clock::now();
+        #endif
         // Compute throughput and storage dependencies
         execStorageDistribution(d);
+        #ifdef LOG_OUT
+        auto endTime = std::chrono::steady_clock::now();
+        std::chrono::duration<double, std::milli> execTime = endTime - startTime; // duration of individual execution
+        #endif
+        #ifdef VERBOSE_OUT
+        computation_counter++;
+        #endif
 
         // Throughput of d larger then current maximum of the set
         if (d->thr > ds->thr)
             ds->thr = d->thr;
 
+        #ifdef LOG_OUT
+        // log execution times (cont. from execStorageDistribution)
+        dseLog << execTime.count() << ";";
+        #endif
+
         // Create new storage distributions for every channel which
         // has a storage dependency in d
         for (uint c = 0; c < g->nrChannels(); c++)
@@ -1167,25 +1500,48 @@
             // Channel c has storage dependency?
             if (d->dep[c])
             {
+              #ifdef VERBOSE_OUT
+              cout << "\tFound storage dependency in channel " << g->getChannel(c)->getName() << endl;
+              #endif
                 // Do not enlarge the channel if its a self-edge
                 if (g->getChannel(c)->getSrcActor()->getId()
-                    == g->getChannel(c)->getDstActor()->getId())
-                    continue;
+                    == g->getChannel(c)->getDstActor()->getId()) {
+                  #ifdef VERBOSE_OUT
+                  cout << "\t\tChannel " << g->getChannel(c)->getName() << " is a self-edge: ignoring" << endl;
+                  #endif
+                  continue;
+                }
 
                 // Create new storage distribution with channel c enlarged
                 dNew = newStorageDistribution();
-                dNew->sz = d->sz + minSzStep[c];
+                if (!useCoarse) {
+                  dNew->sz = d->sz + minSzStep[c];
+                } else {
+                  dNew->sz = d->sz + minSzStep[c] * coarseMultiplier;
+                }
                 dNew->thr = 0;
                 for (uint i = 0; i < g->nrChannels(); i++)
                 {
                     dNew->sp[i] = d->sp[i];
-                    if (i == c)
+                    if (i == c) {
+                      if (!useCoarse) {
                         dNew->sp[i] += minSzStep[c];
+                      } else {
+                        dNew->sp[i] += minSzStep[c] * coarseMultiplier;
+                      }
+                      #ifdef VERBOSE_OUT
+                      cout << "\t\tIncreasing channel size of " << g->getChannel(c)->getName()
+                           << " to " << dNew->sp[i] << endl;
+                      #endif
+                    }
                 }
                 dNew->next = NULL;
                 dNew->prev = NULL;
 
                 // Add storage distribution to set of distributions to be checked
+                #ifdef VERBOSE_OUT
+                cout << "\tUpdating checklist with new storage distribution..." << endl;
+                #endif
                 if (!addStorageDistributionToChecklist(dNew))
                 {
                     // Distribution already in check list
@@ -1193,6 +1549,11 @@
                 }
             }
         }
+        #ifdef LOG_OUT
+        // update real cumulative duration since start of DSE
+        cumulativeTime = std::chrono::steady_clock::now() - cumulativeStart;
+        dseLog << cumulativeTime.count() << endl;
+        #endif
     }
 
     /**
@@ -1209,6 +1570,9 @@
         d = ds->distributions;
         while (d != NULL)
         {
+          #ifdef VERBOSE_OUT
+          cout << "\nExploring new storage distribution:" << endl;
+          #endif
             // Explore distribution d
             exploreStorageDistribution(ds, d);
 
@@ -1217,6 +1581,10 @@
         }
 
         // Remove all non-minimal storage distributions from the set
+        #ifdef VERBOSE_OUT
+        cout << "\tTrying to minimise set with distribution size: "
+             << ds->sz << endl;
+        #endif
         minimizeStorageDistributionsSet(ds);
     }
 
@@ -1247,6 +1615,26 @@
         // Check sets of storage distributions till no distributions left to check,
         // or throughput bound exceeded, or maximal throughput reached
         ds = minStorageDistributions;
+
+        // Initialise log file
+        #ifdef LOG_OUT
+        std::string dseMethodName;
+        if (useSCCStorageDeps) {
+          dseMethodName = "_dselog_sdf3_corrected";
+        } else {
+          dseMethodName = "_dselog_sdf3";
+        }
+        if (useCoarse) {
+          dseMethodName += "_coarse";
+        }
+        dseLog.open(dirName + logDirName + g->getName() + dseMethodName + ".csv");
+        dseLog << "storage distribution size;throughput;channel quantities;computation duration;cumulative duration"
+               << endl; // initialise headers
+        #endif
+
+        #ifdef VERBOSE_OUT
+        cout << "DSE BEGIN:" << endl;
+        #endif
         while (ds != NULL)
         {
             // Explore all distributions with size 'ds->sz'
@@ -1332,6 +1720,83 @@
             for (uint c = 0; c < g->nrChannels(); c++)
                 minStorageDistributions->distributions->sp[c] = 0;
         }
+
+        // print DSE results
+        #ifdef VERBOSE_OUT
+        long int pp_counter = 0;
+        cout << "\nDSE RESULTS [START] (target throughput: " << maxThroughput
+             << "):" << endl;
+
+        for (StorageDistributionSet *p = minStorageDistributions; p != NULL;
+             p = p->next) {
+          cout << "Printing storage distributions of distribution size: "
+               << p->sz << endl;
+          for (StorageDistribution *d = p->distributions; d != NULL;
+               d = d->next) {
+            pp_counter++;
+            cout << "\tCurrent StorageDistribution info:" << endl;
+            cout << "\tNumber of edges: " << g->nrChannels() << endl;
+            cout << "\tChannel quantities:\n\t";
+            for (uint c = 0; c < g->nrChannels(); c++) {
+              if (g->getChannel(c)->getSrcActor()->getId() !=
+                  g->getChannel(c)->getDstActor()->getId()) {
+                cout << d->sp[g->getChannel(c)->getId()] << " ";
+              }
+            }
+            cout << endl;
+            cout << "\tDistribution size: " << d->sz << endl;
+            cout << "\tThroughput: " << d->thr << endl;
+          }
+        }
+        cout << "DSE RESULTS [END]" << endl;
+        cout << "Done with search!" << endl;
+        cout << "Number of computations: " << computation_counter << endl;
+        cout << "Number of pareto points: " << pp_counter << endl;
+        #endif
+
+        #ifdef LOG_OUT
+        dseLog.close(); // DSE logging ends at this point
+        // Variables for pareto point logging
+        ofstream ppLog;
+        std::string ppMethodName;
+        if (useSCCStorageDeps) {
+          ppMethodName = "_pp_sdf3_corrected";
+        } else {
+          ppMethodName = "_pp_sdf3";
+        }
+        if (useCoarse) {
+          ppMethodName += "_coarse";
+        }
+        ppLog.open(dirName + ppDirName + g->getName() + ppMethodName + ".csv");
+        // Initialise log file
+        ppLog << "storage distribution size;throughput;channel quantities" << endl;
+
+        for (StorageDistributionSet *p = minStorageDistributions; p != NULL;
+             p = p->next) {
+          for (StorageDistribution *d = p->distributions; d != NULL;
+               d = d->next) {
+            std::string output("\"");
+            std::string delim("");
+            std::string colDelim(";");
+            uint noFeedbackSize = 0;
+            for (uint c = 0; c < g->nrChannels(); c++) {
+              if (g->getChannel(c)->getSrcActor()->getId() !=
+                  g->getChannel(c)->getDstActor()->getId()) {
+                output += delim;
+                output += std::to_string(d->sp[g->getChannel(c)->getId()]);
+                delim = ",";
+                noFeedbackSize += d->sp[g->getChannel(c)->getId()];
+              }
+            }
+            output += "\"";
+            ppLog << noFeedbackSize << colDelim
+                  << d->thr << colDelim
+                  << output << endl;
+          }
+        }
+        ppLog.close();
+        #endif
+
     }
 
     /**
@@ -1351,6 +1816,12 @@
         minStorageDistributions = NULL;
 
         // Initialize bounds on the search space
+        #ifdef VERBOSE_OUT
+        cout << "INITIALISING SEARCH PARAMETERS:" << endl;
+        #endif
+        #ifdef LOG_OUT
+        cumulativeStart = std::chrono::steady_clock::now(); // DSE cumulative time starts here
+        #endif
         initBoundsSearchSpace(g);
 
         // Create a transition system
diff -ruN sdf3_140724/sdf3/sdf/analysis/buffersizing/buffer.h sdf3_custom/sdf3/sdf/analysis/buffersizing/buffer.h
--- sdf3_140724/sdf3/sdf/analysis/buffersizing/buffer.h	2014-07-24 12:16:04.000000000 +0800
+++ sdf3_custom/sdf3/sdf/analysis/buffersizing/buffer.h	2022-04-13 21:25:58.261736331 +0800
@@ -40,6 +40,7 @@
 
 #include "storage_distribution.h"
 #include "../../base/timed/graph.h"
+#include <stack>
 namespace SDF
 {
     /**
@@ -148,7 +149,13 @@
                     void findCausalDependencies(SDFactor *a, bool **abstractDepGraph);
                     void analyzePeriodicPhase(const TBufSize *sp, bool *dep);
                     void analyzeDeadlock(const TBufSize *sp, bool *dep);
-
+                    void findStorageDependenciesSCC(bool **abstractDepGraph, bool *dep);
+                    void computeDFSStack(uint startId, int *visited,
+                                         bool **abstractDepGraph,
+                                         std::stack<int> &dfsOrder);
+                    void dfsTranspose(uint startId, int *visited,
+                                      bool **abstractDepGraph,
+                                      std::vector<int> &sccNodes);
                     // Compute throughput from transition system
                     TDtime computeThroughput(const StatesIter cycleIter);
 
