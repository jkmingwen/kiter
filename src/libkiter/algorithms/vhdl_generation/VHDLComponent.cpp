/*
 * VHDLComponent.cpp
 *
 *  Created on: 15 June 2021
 *      Author: jkmingwen
 */

#include <models/Dataflow.h>
#include "VHDLComponent.h"

/**
 * \brief Each instance represents a vertex to be implemented as an
 * operator in VHDL.
 * \param dataflow Dataflow graph that vertex is located in.
 * Required to query properties of the vertex.
 * \param a Vertex to instantiate as a VHDLComponent.
 */
VHDLComponent::VHDLComponent(models::Dataflow* const dataflow, Vertex a) {
  actor = a;
  uniqueName = dataflow->getVertexName(a); // unique ID per VHDLComponent
  implementationName = "default"; // name of top-level component for the given operator in VHDL
  componentType = dataflow->getVertexType(a); // vertex type denotes computation performed (sans data type)
  isMixedType = false; // some components (e.g. pow) take in a mix of data types as arguments

  // port names denote input/output data types --- check and track these
  {ForInputEdges(dataflow, a, inEdge) {
      inputPorts.push_back(dataflow->getEdgeOutputPortName(inEdge));
      inputEdges.push_back(dataflow->getEdgeName(inEdge));
    }}
  {ForOutputEdges(dataflow, a, outEdge) {
      outputPorts.push_back(dataflow->getEdgeInputPortName(outEdge));
      outputEdges.push_back(dataflow->getEdgeName(outEdge));
    }}
  for (const auto& port : inputPorts) {
    std::string portName = port;
    if (portName.substr(portName.find_last_of('_') + 1) == "vect") { // ignore "vect" to find the actual data type
      portName.erase(portName.find_last_of('_'), std::string::npos);
    }
    inputTypes[portName.substr(portName.find_last_of('_') + 1)]++;
  }
  for (const auto& port : outputPorts) {
    std::string portName = port;
    if (portName.substr(portName.find_last_of('_') + 1) == "vect") { // ignore "vect" to find the actual data type
      portName.erase(portName.find_last_of('_'), std::string::npos);
    }
    outputTypes[portName.substr(portName.find_last_of('_') + 1)]++;
  }

  // IDs of input/output actors used for signal matching in generateVHDLArchitecture
  if (componentType.find("INPUT") != std::string::npos ||
      componentType.find("OUTPUT") != std::string::npos) {
    ioId = std::stoi(componentType.substr(componentType.find('_') + 1, std::string::npos));
    componentType = componentType.substr(0, componentType.find("_")); // necessary to strip ID from name (e.g. "INPUT_0") so we can parse it as a generic INPUT/OUTPUT component
  }

  /* Identify order of arguments for operators.
     Order of arguments for operators are denoted by their name (e.g.
     compName_arg0_arg1_arg2). Proj actors generated by the singleOutput
     function have the same naming convention so ignore these as they only
     have 1 input. */
  if (componentType != "Proj") {
    std::string argFromName = uniqueName;
    size_t pos = argFromName.rfind('_');
    std::string argName;
    while ((pos = argFromName.rfind('_')) != std::string::npos) { // start from last argument
      argName = argFromName.substr(pos + 1);
      argOrder.insert(argOrder.begin(), argName); // retain correct order of arguments
      argFromName.erase(pos);
    }
  }

  /* TODO identify data type of component to select appropriate VHDL implementation
     data type produced by constant value and UI components determine their data type
     all other types of operators use input types */
  std::istringstream stringAsNumber(componentType); // just to test if strings are numbers
  float compTypeAsFloat;
  stringAsNumber >> std::noskipws >> compTypeAsFloat;
  if (std::count(uiTypes.begin(), uiTypes.end(), componentType) ||
      (stringAsNumber.eof() && !stringAsNumber.fail())) {
    if (outputTypes.size() > 1 || !outputTypes.size()) {
      VERBOSE_ERROR("UI/Constant value component "
                    << uniqueName
                    << " should have just one output data type");
    }
    if (outputTypes.begin()->first == "real") {
      dataType = "fp";
    } else if (outputTypes.begin()->first == "int") {
      dataType = "int";
    } else {
      VERBOSE_ERROR("Unsupported data type: " << dataType);
    }
  } else {
    if (inputTypes.empty() && componentType != "INPUT") {
      VERBOSE_ERROR(uniqueName << " (" << componentType << ")"
                                  << " should have at least 1 input");
    }
    // determine data type via input ports
    bool isInt = false, isFloat = false;
    for (auto &type : inputTypes) {
      if (type.first == "real") {
        isFloat = true;
      } else if (type.first == "int") {
        isInt = true;
      } else {
        VERBOSE_ERROR("\tUndefined input type detected: " << type.first);
      }
    }
    if (isInt && isFloat) {
      VERBOSE_WARNING("\tBoth Int and Float types detected for "
                      << uniqueName << "(" << componentType
                      << "), setting type to floating point");
      dataType = "fp";
      isMixedType = true;
    } else if (isFloat) {
      dataType = "fp";
    } else if (isInt) {
      dataType = "int";
    }
  }

  // data type added to componentType to determine appropriate VHDL implementation to use
  if (std::count(arithmeticTypes.begin(), arithmeticTypes.end(), componentType) ||
      std::count(numOperatorTypes.begin(), numOperatorTypes.end(), componentType)) {
    componentType = dataType + "_" + componentType;
  } else if ((stringAsNumber.eof() && !stringAsNumber.fail())) { // string is a number
    componentType = "const_value";
    if (dataType == "fp") {
      fpValue = compTypeAsFloat;
    } else {
      intValue = (int) compTypeAsFloat;
    }
  }
}

Vertex VHDLComponent::getActor() const {
  return this->actor;
}

std::string VHDLComponent::getUniqueName() const {
  return this->uniqueName;
}

int VHDLComponent::getIOId() const {
  VERBOSE_ASSERT((this->getType() == "INPUT" || this->getType() == "OUTPUT"),
                 "Trying to get I/O ID for a component that hasn't been declared as type input/output.");
  return this->ioId;
}

const std::vector<std::string>& VHDLComponent::getInputPorts() const{
  return this->inputPorts;
}

const std::vector<std::string>& VHDLComponent::getOutputPorts() const{
  return this->outputPorts;
}

const std::vector<std::string>& VHDLComponent::getInputEdges() const{
  return this->inputEdges;
}

const std::vector<std::string>& VHDLComponent::getOutputEdges() const{
  return this->outputEdges;
}

std::string VHDLComponent::getType() const{
  return this->componentType;
}

/* NOTE in the future, if we intend to implement setting different frequencies
   for each operator, generating their component names based on compType and
   operatorFreq would be one way of going about it */
std::string VHDLComponent::getImplementationName() const{
  return this->implementationName;
}

const std::vector<std::string>& VHDLComponent::getArgOrder() const{
  return this->argOrder;
}

const std::map<std::string, int>& VHDLComponent::getInputTypes() const{
  return this->inputTypes;
}

const std::map<std::string, int>& VHDLComponent::getOutputTypes() const{
  return this->outputTypes;
}

void VHDLComponent::setDataType(const std::string& newType) {
  this->dataType = newType;
}

std::string VHDLComponent::getDataType() const{
  return this->dataType;
}

bool VHDLComponent::isConst() const {
  return this->componentType == "const_value";
}

bool VHDLComponent::isUI() const {
  if (std::count(uiTypes.begin(), uiTypes.end(), this->componentType)) {
    return true;
  } else {
    return false;
  }
}

bool VHDLComponent::hasMixedType() const{
  return this->isMixedType;
}

void VHDLComponent::setFPValue(const float& newVal) {
  this->fpValue = newVal;
}

void VHDLComponent::setIntValue(const int& newVal) {
  this->intValue = newVal;
}

float VHDLComponent::getFPValue() const {
  return this->fpValue;
}

int VHDLComponent::getIntValue() const {
  return this->intValue;
}

void VHDLComponent::setUniqueName(const std::string& newName) {
  this->uniqueName = newName;
}

void VHDLComponent::setImplementationName(const std::string& newName) {
  this->implementationName = newName;
}

void VHDLComponent::setIOId(int id) {
  VERBOSE_ASSERT((this->getType() == "INPUT" || this->getType() == "OUTPUT"),
                 "Trying to set I/O ID for a component that hasn't been declared as type input/output.");
  this->ioId = id;
}

std::string VHDLComponent::printStatus() const  {
  std::stringstream outputStream;

  outputStream << "\nActor " << this->getUniqueName() << std::endl;
  outputStream << "\tType: " << this->getType() << std::endl;
  outputStream << "\tData type: " << this->getDataType() << std::endl;
  if (!argOrder.empty()) {
    outputStream << "\tArgument actors:" << std::endl;
    int order = 1;
    for (auto& i : argOrder) {
      outputStream << "\t\t" << order << ". " << i << std::endl;
      order++;
    }
  }
  outputStream << "\tInput ports: " << std::endl;
  for (auto portName : this->getInputPorts()) {
    outputStream << "\t\t" << portName << std::endl;
  }
  outputStream << "\tOutput ports: " << std::endl;
  for (auto portName : this->getOutputPorts()) {
    outputStream << "\t\t" << portName << std::endl;
  }
  outputStream << "\tInput edges: " << std::endl;
  for (auto portName : this->getInputEdges()) {
    outputStream << "\t\t" << portName << std::endl;
  }
  outputStream << "\tOutput edges: " << std::endl;
  for (auto portName : this->getOutputEdges()) {
    outputStream << "\t\t" << portName << std::endl;
  }
  outputStream << "\tInput types: " << std::endl;
  for (auto inType : this->inputTypes) {
    outputStream << "\t\t" << inType.first << ", " << inType.second << std::endl;
  }
  outputStream << "\tOutput types: " << std::endl;
  for (auto outType : this->outputTypes) {
    outputStream << "\t\t" << outType.first << ", " << outType.second << std::endl;
  }
  outputStream << "\tIs constant?";
  if (this->componentType == "const_value") {
    outputStream << " Y" << std::endl;
    if (this->dataType == "real") {
      outputStream <<"\t\tValue: " << this->fpValue << std::endl;
    } else if (this->dataType == "int") {
      outputStream <<"\t\tValue: " << this->intValue << std::endl;
    } // TODO add else for edge cases
  } else {
    outputStream << " N" << std::endl;
  }

  return outputStream.str();
}
